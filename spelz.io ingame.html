<!DOCTYPE html>
<html>
<head>
	<title>Spelz.io</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
		html, body {
			height: 100%;
			margin: 0;
		}

		button {
			height: 100px;
			width: 100px;
		}

		div {
			border: 1px solid blue;
		}

		#mycanvas {
			border: 1px solid #d3d3d3;
			background-color: #f1f1f1;
			position: absolute;
			z-index: -1;
		}

		#startGameMenu {
			border: 1px solid blue;
			position: absolute;
			z-index: 1;
			height: calc(100% - 7px);
			width: calc(100% - 7px);
			display: flex;
			flex-direction: row;
			justify-content: space-between;
			align-content: flex-start;
			padding: 2px;
		}
        #inputUserName {
           width:500px;
		   height:50px;
        }

		.spelzio {
			margin: 0;
			font-size: 180px;
		}

		.notstart {
			width: 100px;
			height: 70px;
			margin: 3px;
		}

		.containera {
			display: flex;
			flex-direction: column;
			justify-content: space-between;
		}

		.item1a {
			text-align: center;
			margin: 2px;
		}

		.item2a {
			text-align: start;
			margin: 2px;
			padding: 0px;
			font-size: 25px;
		}

		.containerb {
			display: flex;
			flex-direction: column;
			justify-content: center;
			flex-grow: 1;
			margin: 2px;
		}

		.item1b {
			margin: 10px;
			text-align: center;
			margin: 2px;
			font-size: 40px;
		}

		.containerc {
			text-align: end;
			margin: 2px;
			padding: 2px 10px 2px 10px;
		}
	</style>
</head>
<body>
	<canvas id="mycanvas"></canvas>
	<div id="startGameMenu">
		<div class="containera">
			<div class="item1a">
				<button class="notstart">settings</button>
				<button class="notstart">changelog</button>
			</div>
			<div class="item2a">
				<button class="notstart">friends</button><br>
				<button class="notstart">spelz</button><br>
				<button class="notstart">monster gallery</button>
			</div>
		</div>
		<div class="containerb">
			<div class="item1b">
				<h1 class="spelzio">spelz.io</h1>
				<input id="inputUserName" type="text" placeholder="Name" />
				<button id="startGameButton" onclick="startGame()">start game</button>
			</div>
		</div>
		<div class="containerc">
			<a href="signin.html">sign in</a>
		</div>
	</div>
	<script type="text/javascript" src="js/mob.js"></script>
	<script type="text/javascript" src="js/playable-character.js"></script>
	<script type="text/javascript" src="js/spellbook.js"></script>
	<script type="text/javascript" src="js/basicMob.js"></script>

	<script>
		let basicMobArray = [];
        let maxAmountBasicMob = 5;
		let spellBooks = [];
		let maxSpellBooks = 3;
		const pi = 3.14159;
        let spawnSpellBookTimeout = [];

		var myGameArea = {
			activeButtons: [],
			activeKeys: [],
            validKeys: ["KeyW", "KeyA", "KeyS", "KeyD", "ArrowUp", "ArrowLeft", "ArrowDown", "ArrowRight", "Space", "ShiftLeft", "ShiftRight"],
			canvas: document.getElementById("mycanvas"),
			start: function () {
				this.context = this.canvas.getContext("2d");
				this.interval = setInterval(updateGameArea, 20);
				window.addEventListener('keydown', function(e) {
					var isKeyActive = myGameArea.activeKeys.indexOf(e.code) >= 0;
					if (!isKeyActive) {
						var isValidKey = myGameArea.validKeys.indexOf(e.code) >= 0;
						if (isValidKey) {
							myGameArea.activeKeys.push(e.code);                       
						}
					}
				});
				window.addEventListener('keyup', function(e) {
					var keyIndex = myGameArea.activeKeys.indexOf(e.code);
					var isKeyActive = keyIndex >= 0;
					if (isKeyActive) {
						myGameArea.activeKeys.splice(keyIndex, 1);
					}
				});
				//lets you use mouse buttons
				//				this.canvas.addEventListener("mousedown", function (e) {
				//					var isButtonActive = myGameArea.activeButtons.indexOf(e.button) >= 0;
				//					if (!isButtonActive) {
				//						myGameArea.activeButtons.push(e.button);
				//					}
				//					console.log(myGameArea.activeButtons);
				//					console.log("mousedown");
				//				});
			},
			clear: function () {
				this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
			},
			stop: function () {
				clearInterval(this.interval);
			}
		}
		function startGame() {
            myGameArea.activeKeys = [];
            basicMobArray = [];
			spellBooks = [];
            for (var i = 0; i < spawnSpellBookTimeout.length; i++) {
                clearTimeout(spawnSpellBookTimeout[i]);
			}
			console.log("Timeouts cleared");
			spawnSpellBookTimeout = [];

			myGameCharacter = new PlayableCharacter(300, 300, 15, "yellow", 150, 10);
            spawnBasicMob();
			myGameArea.start();
			myGameCharacter.update();
			basicMobArray.forEach(item => {
				item.update();
			});
			spellBooksKeeper();
			var startGameMenuVariable = document.getElementById("startGameMenu");
			startGameMenuVariable.remove();
		}

		function spellBooksKeeper() {
            spawnSpellBook(new SpellBook(myGameCharacter.x, myGameCharacter.y, 10, '#f0f', 0, 45, 20, 70, 1, 10, 1500), 10);
            spawnSpellBook(new SpellBook(myGameCharacter.x, myGameCharacter.y, 10, 'white', 1, 45, 20, 70, 1, 10, 1500), 10);
            spawnSpellBook(new SpellBook(myGameCharacter.x, myGameCharacter.y, 10, '#f00', 2, 45, 20, 70, 1, 10, 1500), 10);
			for (var i = 0; i < spellBooks.length; i++) {
				if (i > 0) {
					spellBooks[i].radian = ((i * pi) / maxSpellBooks) * 2;
				}
				console.log(spellBooks[i].radian);
			}
		}
		function spellBooksUpdater() {
			spellBooks.forEach(spellBook => {
				spellBook.startingPos = {
					x: myGameCharacter.x,
					y: myGameCharacter.y
				}
				if (spellBook.orbitRadius < spellBook.normalOrbitRadius) {
					spellBook.orbitRadius += 1;
				}
				else if (spellBook.orbitRadius > spellBook.normalOrbitRadius) {
					spellBook.orbitRadius -= 1;
				}
				spellBook.update();
			});
		}
		function updateGameArea() {
			// always updating
			myGameArea.clear();
			myGameArea.context.canvas.width = window.innerWidth - 3;
			myGameArea.context.canvas.height = window.innerHeight - 3;
			spellBooksUpdater();
			myGameCharacter.update();
			basicMobArray.forEach(basicMob => {
				basicMob.update();
			});	
			// death
			if (crashWith(myGameCharacter, basicMobArray)) {
				alert("game over");
				
				myGameArea.stop();
				startGame();
			}
			// hitting a basic mob
			else if (crashWithSpellBook(spellBooks, basicMobArray)) {
				myGameCharacter.x += myGameCharacter.speedX;
				myGameCharacter.y += myGameCharacter.speedY;
			}
			//not moving anything
			else if ((myGameArea.activeKeys.length == 0) && (myGameArea.activeButtons.length == 0)) {
			}
			//updates when moving
			else {
				myGameCharacter.x += myGameCharacter.speedX;
				myGameCharacter.y += myGameCharacter.speedY;
			}
			myGameCharacter.speedX = 0;
			myGameCharacter.speedY = 0;
			var gameSpeed = myGameCharacter.speed;

			for (var i = 0; i < myGameArea.activeKeys.length; i++) {
				var key = myGameArea.activeKeys[i];

				if ((key == "ArrowLeft" || key == "KeyA") && (myGameCharacter.speedX > -gameSpeed)) {
					myGameCharacter.speedX -= gameSpeed;
				}
				if ((key == "ArrowRight" || key == "KeyD") && (myGameCharacter.speedX < gameSpeed)) {
					myGameCharacter.speedX += gameSpeed;
				}
				if ((key == "ArrowUp" || key == "KeyW") && (myGameCharacter.speedY > -gameSpeed)) {
					myGameCharacter.speedY -= gameSpeed;
				}
				if ((key == "ArrowDown" || key == "KeyS") && (myGameCharacter.speedY < gameSpeed)) {
					myGameCharacter.speedY += gameSpeed;
				}
// attack/spacebar
				if (key == "Space") {
					spellBooks.forEach(spellBook => {
						if (spellBook.orbitRadius < spellBook.attackOrbitRadius) {
							spellBook.orbitRadius += 2;		
						}
					});
				}
// defend/shift
				if (key == "ShiftLeft") {
					spellBooks.forEach(spellBook => {
						if (spellBook.orbitRadius > spellBook.defendOrbitRadius) {
							spellBook.orbitRadius -= 2;
						}
					});
				}
			}
		}
		function spawnBasicMob() {
			let me = this;
            setTimeout(function () {
                if (basicMobArray.length < maxAmountBasicMob) {
                    let basicMobRandomX = Math.floor((Math.random() * 1000) + 10);
                    let basicMobRandomY = Math.floor((Math.random() * 1000) + 10);
                    let basicMobRandomRadiusXHealth = Math.floor((Math.random() * 70) + 10);
                    let newBasicMob = new BasicMob(basicMobRandomX, basicMobRandomY, basicMobRandomRadiusXHealth, "#1db555", basicMobRandomRadiusXHealth, 1);
                    basicMobArray.push(newBasicMob);
					if (basicMobArray.length < maxAmountBasicMob) {
						me.spawnBasicMob();
					}
                }
            }, 3000);
		}
		function spawnSpellBook(spellBook, delay) {
            spawnSpellBookTimeout.push(setTimeout(function () {
                let spellBook1Radian = 0;
                let newSpellBook = new SpellBook(spellBook.x, spellBook.y, spellBook.radius, spellBook.color, spellBook.positionIndex, spellBook.normalOrbitRadius, spellBook.defendOrbitRadius, spellBook.attackOrbitRadius, spellBook.health, spellBook.damage, spellBook.respawnTime);
                let radianMultiplier = (pi / maxSpellBooks) * 2;
                if (spellBooks.length > 0) {
                    spellBook1Radian = spellBooks[0].radian;
                    newSpellBook.radian = spellBook1Radian + (radianMultiplier * (spellBook.positionIndex));
                }
                else {
                    newSpellBook.radian = 0;
				}
//				newSpellBook.radian = spellBook.radian;
//				newSpellBook.radian = newSpellBook.radian + (spellBook.velocity * (delay / 20));
//                newSpellBook.radian = ((spellBook.radianLevel * pi) / maxSpellBooks) * 2;
				spellBooks.push(newSpellBook);
//                console.log("Spellbook spawned." + delay);
			}, delay)
			);
		}
		function crashWith(spellBook, basicMobs) {
			let result = false;
			basicMobs.forEach(basicMob => {
				let radii = spellBook.radius + basicMob.radius;
				let distance = getDistance(spellBook, basicMob);
				let hasCrashed = distance < radii;
				if (hasCrashed) {
					result = hasCrashed;
				}
			});
			return result;
		}
		function crashWithSpellBook(spellBooks, basicMobs) {
			let result = false;
			spellBooks.forEach(spellBook => {
				var basicMobIndex = 0;
				basicMobs.forEach(basicMob => {
					let radii = spellBook.radius + basicMob.radius;
					let distance = getDistance(spellBook, basicMob);
					let hasCrashed = distance < radii;
					if (hasCrashed) {
						result = hasCrashed;
						if (basicMob.health > spellBook.damage) {
                            basicMob.health -= spellBook.damage;
							basicMob.radius -= spellBook.damage;
							spellBook.health -= basicMob.damage;
						}	else if (basicMob.health <= spellBook.damage) {
							spellBook.health -= basicMob.damage;
							basicMobs.splice(basicMobIndex, 1);
							spawnBasicMob();
						}
                        if (spellBook.health <= 0) {
                            var spellBookIndex = spellBooks.indexOf(spellBook);
                            spellBooks.splice(spellBookIndex, 1);
                            if (spellBooks.length < maxSpellBooks) {
                                spawnSpellBook(spellBook, spellBook.respawnTime);
                            }
                        }
						basicMob.update();
					}
					basicMobIndex++;
				});
			});
			return result;
		}
		function getDistance(circle1, circle2) {
			let a = circle2.y - circle1.y;
			let b = circle2.x - circle1.x;
			return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
		}
		/*	tasks:
		1). the game shall now push spellbooks 
		1). make the game update the spell books position based on the max spellbooks amount
		1). make the game over alert box take you to the game menu instead
		1). fix the mob radius and health thing so that the basic mob will die at health 0
		1). mob knocks back player instead of killing
		2). basic mob version 2 (this one moves but doesnt attack)
		3). not pressing shift or spacebar makes the spell book act passively(it will move around but will still follow you)
		4). make the a field of view that follows the player
		4). add a new spellBook other than the basic one
		5). make basic mob drop a new spell book
		6). add a way to access spell books
		7). make it easier to add petals / make a shortcut for adding petals
		8). make a stable radian var for all spell books		
		100). add fire guided projectile
		1000). add a place where npcs will go to when their kingdom is invaded
		1001). most people arent allowed to go to that place because that place is only for emergencies and they cant risk it getting invaded
		1002). make npcs killable (someone rich and willing needs to resurect them) (there will be a sign that says theyve been killed or something)
		1003). squads/teams will be a thing where friends can play together
		1004). there should be a local gamemode so people can still have fun
		1005). only add some ads
		1006). ranks should be a thing
		*/
	</script>
</body>
</html>
