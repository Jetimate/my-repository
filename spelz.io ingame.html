<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border:1px solid #d3d3d3;
    background-color: #f1f1f1;
}
</style>
</head>
<body onload="startGame()">
	<script type="text/javascript" src="js/mob.js"></script>
	<script type="text/javascript" src="js/playable-character.js"></script>
	<script type="text/javascript" src="js/spellbook.js"></script>

	<script>
		function startGame() {
			myGameCharacter = new PlayableCharacter(300, 300, 15, "yellow", 150, 10);
			mobArray.push(new Mob(200, 200, 30, "red", 30, 1));
			myGameArea.start();
			myGameCharacter.update();
			mobArray.forEach(item => {
				item.update();
			});
			spellBooksKeeper();
		}

		var myGameArea = {
			activeKeys: [],
			validKeys: [37, 38, 39, 40, 65, 68, 83, 87, 97, 100, 119, 115],
			canvas : document.createElement("canvas"),
			start : function() {

				this.canvas.width = 1265;
				this.canvas.height = 698;
				this.context = this.canvas.getContext("2d");

				document.body.insertBefore(this.canvas, document.body.childNodes[0]);
				this.interval = setInterval(updateGameArea, 20);
				window.addEventListener('keydown', function (e) {
					var isKeyActive = myGameArea.activeKeys.indexOf(e.keyCode) >= 0;
					if (!isKeyActive) {
						var isValidKey = myGameArea.validKeys.indexOf(e.keyCode) >= 0;
						if (isValidKey) {
							myGameArea.activeKeys.push(e.keyCode);
						}
					}
					console.log(myGameArea.activeKeys);
					console.log("keydown");
				});
				window.addEventListener('keyup', function (e) {
					var keyIndex = myGameArea.activeKeys.indexOf(e.keyCode);
					var isKeyActive = keyIndex >= 0;
					if (isKeyActive)
						myGameArea.activeKeys.splice(keyIndex, 1);

					console.log(myGameArea.activeKeys);
					console.log("keyup");
				});
			},
			clear : function(){
				this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
			},
			stop : function() {
				clearInterval(this.interval);
			}
		}

		let mobArray = [];
		let spellBooks;
		var pi = 3.14159;
		function spellBooksKeeper() {
			spellBooks = [];
            spellBooks.push(new SpellBook(myGameCharacter.x, myGameCharacter.y, 10, 'red', 45, 1, 1, 1500));
            spellBooks.push(new SpellBook(myGameCharacter.x, myGameCharacter.y, 10, 'blue', 45, 1, 1, 1500));
            spellBooks.push(new SpellBook(myGameCharacter.x, myGameCharacter.y, 10, 'gray', 45, 1, 1, 1500));
		//	spellBooks.push(new SpellBook(myGameCharacter.x, myGameCharacter.y, 10, 'gray', 45, 1, 1, 1500));
		//	spellBooks.push(new SpellBook(myGameCharacter.x, myGameCharacter.y, 10, 'gray', 45, 1, 1, 1500));
		//	spellBooks.push(new SpellBook(myGameCharacter.x, myGameCharacter.y, 10, 'gray', 45, 1, 1, 1500));
			for (var i = 0; i< spellBooks.length; i++) {
				if (i>0)
                    spellBooks[i].radian = ((i * pi) / (spellBooks.length)) * 2;					
			}
			console.log(spellBooks[0].radian);
			console.log(spellBooks[1].radian);
			console.log(spellBooks[2].radian);
//          console.log(spellBooks[3].radian);
//			console.log(spellBooks[4].radian);
//          console.log(spellBooks[5].radian);
		}
		function spellBooksUpdater() {
			spellBooks.forEach(spellBook => {
				spellBook.startingPos = {
					x: myGameCharacter.x,
					y: myGameCharacter.y
				}
                if (spellBook.orbitRadius < spellBook.normalOrbitRadius) {
                    spellBook.orbitRadius += 1;
                }
				spellBook.update();
			});
		}
		function updateGameArea() {

			if (crashWith(myGameCharacter, mobArray)) {
				myGameArea.activeKeys = [];
				alert("game over");
				myGameArea.stop();
				startGame();
			}

			else if (crashWithSpellBook(spellBooks, mobArray)) {
				myGameArea.clear();
				myGameCharacter.x += myGameCharacter.speedX;
				myGameCharacter.y += myGameCharacter.speedY;
				spellBooksUpdater();
				myGameCharacter.update();

				mobArray.forEach(mob => {
					mob.update();
				});
			}
			else if (myGameArea.activeKeys.length == 0) {
				myGameArea.clear();
				spellBooksUpdater();
				myGameCharacter.update();  
				
				mobArray.forEach(mob => {
					mob.update();
				});

				return;
			}
			else {
				myGameArea.clear();
				myGameCharacter.x += myGameCharacter.speedX;
				myGameCharacter.y += myGameCharacter.speedY;
				spellBooksUpdater();
				myGameCharacter.update();

				mobArray.forEach(mob => {
					mob.update();
				});
			}

			myGameCharacter.speedX = 0;
			myGameCharacter.speedY = 0;

			var gameSpeed = myGameCharacter.speed;

			for (var i = 0; i < myGameArea.activeKeys.length; i++) {
				var key = myGameArea.activeKeys[i];

				if ((key == 37 || key == 65 || key == 97) && (myGameCharacter.speedX > -gameSpeed)) {
					myGameCharacter.speedX-=gameSpeed;
				}
				if ((key == 39 || key == 68 || key == 100) && (myGameCharacter.speedX < gameSpeed)) {
					myGameCharacter.speedX+=gameSpeed;
				}
				if ((key == 38 || key == 87 || key == 119) && (myGameCharacter.speedY > -gameSpeed)) {
					myGameCharacter.speedY-=gameSpeed;
				}
				if ((key == 40 || key == 83 || key == 115) && (myGameCharacter.speedY < gameSpeed)){
					myGameCharacter.speedY+=gameSpeed;
				}
			}
		}
		function crashWith(spellBook, mobs) {
			let result = false;
			mobs.forEach(mob => {
				let radii = spellBook.radius + mob.radius;
				let distance = getDistance(spellBook, mob);

				let hasCrashed = distance < radii;
				if (hasCrashed) {
					result = hasCrashed;
				}
			});
			return result;
		}
		function crashWithSpellBook(spellBooks, mobs) {
			let result = false;
			spellBooks.forEach(spellBook => {
				var mobIndex = 0;
				mobs.forEach(mob => {

					let radii = spellBook.radius + mob.radius;
					let distance = getDistance(spellBook, mob);

					let hasCrashed = distance < radii;
					if (hasCrashed) {
						result = hasCrashed;
						mob.health -= spellBook.damage;
						mob.radius -= spellBook.damage;
						spellBook.health -= mob.damage
						console.log(mob.health);

						if (mob.health <= 0) {
							mobs.splice(mobIndex, 1);
						}
						else if (spellBook.health <= 0) {
							var spellBookIndex = spellBooks.indexOf(spellBook);
							spellBooks.splice(spellBookIndex, 1);
							console.log("radian: " + spellBook.radian);
//                          console.log("spellBooks health: " + spellBook.health);
//                          console.log("spellBooks count: " + spellBooks.length);
                            if (spellBooks.length < 3) {
								setTimeout(function () {
									let spellBook1Radian = 0;
									if (spellBooks.length > 0) {
										spellBook1Radian = spellBooks[0].radian;
									}
									let newSpellBook = new SpellBook(myGameCharacter.x, myGameCharacter.y, 10, 'gray', 45, 1, 1, 1500);
         //                           newSpellBook.radian = ((spellBookIndex) * pi) / (spellBooks.length + 1);
									//newSpellBook.radian = (spellBook1Radian / newSpellBook.radian) * pi;
									if (spellBooks.length > 0 && spellBooks[3].health <= 0)
                                        newSpellBook.radian = spellBook1Radian + 4.188786666666666;
									else
										newSpellBook.radian = 0;

									console.log("radian1: " + spellBook1Radian + " radian2: " + newSpellBook.radian);

									spellBooks.push(newSpellBook);
                                },
                                    spellBook.respawnTime
                                );
                            }
						}						
						mob.update();
					}
					mobIndex++;
				});

			});

			return result;
		}
		function getDistance(circle1, circle2) {
			let a = circle2.y - circle1.y;
			let b = circle2.x - circle1.x;
			return Math.sqrt( Math.pow(a,2) + Math.pow(b,2));
        }
		/*	task of the week:
		1). fix radian reload of petals
		2). fix player death update
		3). fix deprecated keycode
		4). make it easier to add petals / make a shortcut for adding petals
		*/
	</script>
</body>
</html>
