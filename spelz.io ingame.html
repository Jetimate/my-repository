<!DOCTYPE html>
<html>
<head>
	<title>Spelz.io</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
		html, body {
			height: 100%;
			margin: 0;
		}

		button {
			height: 100px;
			width: 100px;
		}

        div {
            /*border: 1px solid blue;*/
        }

        #mycanvas {
            border: 1px solid #d3d3d3;
            background-color: #f1f1f1;
            position: absolute;
            z-index: -1;
        }

		#mainMenu {
			border: 1px solid blue;
			position: absolute;
			z-index: 1;
			height: calc(100% - 7px);
			width: calc(100% - 7px);
			display: flex;
			flex-direction: row;
			justify-content: space-between;
			align-content: flex-start;
			padding: 2px;
		}
        #inputUserName {
           width:500px;
		   height:50px;
        }

		.spelzio {
			margin: 0;
			font-size: 180px;
		}

		.notstart {
			width: 100px;
			height: 70px;
			margin: 3px;
		}

		.containera {
			display: flex;
			flex-direction: column;
			justify-content: space-between;
		}

		.item1a {
			text-align: center;
			margin: 2px;
		}

		.item2a {
			text-align: start;
			margin: 2px;
			padding: 0px;
			font-size: 25px;
		}

		.containerb {
			display: flex;
			flex-direction: column;
			justify-content: center;
			flex-grow: 1;
			margin: 2px;
		}

		.item1b {
			margin: 10px;
			text-align: center;
			margin: 2px;
			font-size: 40px;
		}

		.containerc {
			text-align: end;
			margin: 2px;
			padding: 2px 10px 2px 10px;
		}
	</style>
</head>
<body>
	<canvas id="mycanvas"></canvas>
	<div id="mainMenu">
		<div class="containera">
			<div class="item1a">
				<button class="notstart">settings</button>
				<button class="notstart">changelog</button>
			</div>
			<div class="item2a">
				<button class="notstart">friends</button><br>
				<button class="notstart">spelz</button><br>
				<button class="notstart">monster gallery</button>
			</div>
		</div>
		<div class="containerb">
			<div class="item1b">
				<h1 class="spelzio">spelz.io</h1>
				<input id="inputUserName" type="text" placeholder="Name" />
				<button id="startGameButton" onclick="startGame()">start game</button>
			</div>
		</div>
		<div class="containerc">
			<a href="signin.html">sign in</a>
		</div>
	</div>
	<script type="text/javascript" src="js/mob.js"></script>
	<script type="text/javascript" src="js/playableCharacter.js"></script>
	<script type="text/javascript" src="js/spellBook.js"></script>
	<script type="text/javascript" src="js/spell.js"></script>
	<script type="text/javascript" src="js/button.js"></script>
	<script type="text/javascript" src="js/background.js"></script>
	<script type="text/javascript" src="js/camera.js"></script>
	<script type="text/javascript" src="js/loot.js"></script>

	<script>
		const keys = {
			KeyW: false,
			KeyA: false,
			KeyS: false,
			KeyD: false,
			ArrowUp: false,
			ArrowDown: false,
			ArrowLeft: false,
			ArrowRight: false,
			Digit1: false,
			Digit2: false,
			Digit3: false,
			Digit4: false,
			Digit5: false,
            Digit6: false,
            Digit7: false,
            Digit8: false,
            Digit9: false,
			ShiftLeft: false,
			ShiftRight: false,
			Space: false,
			KeyB: false
		};
		let isMouseDown = false;
		let mouseX = 0;
		let mouseY = 0;
		let castMouseX = 0;
		let castMouseY = 0;
		let mouseClickX = 0;
		let mouseClickY = 0;
		let worldX = null;
		let worldY = null;
        let slot3Active = false;
        let slot4Active = false;
        let slot5Active = false;
		let slot6Active = false;
        let slot7Active = false;
        let slot8Active = false;
        let slot9Active = false;
		let mobsArray = [];
		let lootsArray = [];
        let inventoryArray = [];
		let buttonsArray = [];
		let spellBooksArray = [];
		let spellsArray = [];
		let maxExperience = 20;
		const canvas = document.getElementById("mycanvas");
		const ctx = canvas.getContext("2d");
		// loot drops
		const spikeLootDrop = {
			radius: 20,
			name: "spikeLootDrop",
			spellName: "castSpike",
            appearance: "enchantedBook.png",
            ignoreCollision: false,
            text: "spike"
		};
        const luminousEnergyLootDrop = {
            radius: 20,
            name: "luminousEnergyLootDrop",
            spellName: "castLuminousEnergy",
            appearance: "enchantedBook.png",
            ignoreCollision: false,
            text: "lumenergy"
        };
        const luminousSpiritLootDrop = {
            radius: 20,
			name: "luminousSpiritLootDrop",
            spellName: "summonSpirit",
            appearance: "enchantedBook.png",
            ignoreCollision: false,
            text: "spirit"
		};
        const specterLootDrop = {
            radius: 20,
			name: "specterLootDrop",
            spellName: "summonSpecter",
            appearance: "enchantedBook.png",
            ignoreCollision: false,
            text: "specter"
		};
        const teleportLootDrop = {
            radius: 20,
			name: "teleportLootDrop",
            spellName: "teleport",
            appearance: "enchantedBook.png",
            ignoreCollision: false,
            text: "teleport"
		};
        const smashLootDrop = {
            radius: 20,
			name: "smashLootDrop",
            spellName: "smash",
            appearance: "enchantedBook.png",
            ignoreCollision: false,
            text: "smash"
        };
        // mobs
		const luminousRock = {
			radiusAdjust: 0,
            maxAmount: 20,
            mobName: "luminousRock",
            appearance: "luminousRock.png",
			ignoreSpellCollision: true,
			ignoreMobCollision: false,
			defense: 0,
            damage: 1,
            type: "passive",
            ability: "nothing",
            lootDrop: luminousEnergyLootDrop,
            intelligence: 0,
            respawnTime: 3000
        };
		const luminousSpirit = {
            radiusAdjust: 0,
            maxAmount: 10,
            mobName: "luminousSpirit",
            appearance: "luminousSpirit.png",
            ignoreSpellCollision: false,
			ignoreMobCollision: false,
            defense: 0,
            damage: 1,
            type: "passive",
            ability: "nothing",
            lootDrop: luminousSpiritLootDrop,
            intelligence: 1,
            respawnTime: 4000
        };
		const specter = {
            radiusAdjust: 0,
            maxAmount: 5,
            mobName: "specter",
            appearance: "specter.png",
            ignoreSpellCollision: false,
			ignoreMobCollision: false,
            defense: 0,
            damage: 3,
            type: "hostile",
            ability: "nothing",
            lootDrop: specterLootDrop,
            intelligence: 1,
            respawnTime: 8000
		};
        const darkForestTree = {
            radiusAdjust: 20,
            maxAmount: 20,
            mobName: "darkForestTree",
            appearance: "darkForestTree.png",
            ignoreSpellCollision: true,
            ignoreMobCollision: false,
            defense: 1,
            damage: 1,
            type: "passive",
            ability: "nothing",
            lootDrop: spikeLootDrop,
            intelligence: 0,
            respawnTime: 8000
		};
        const darkForestTreant = {
            radiusAdjust: 20,
            maxAmount: 5,
            mobName: "darkForestTreant",
            appearance: "darkForestTreant.png",
            ignoreSpellCollision: true,
            ignoreMobCollision: false,
            defense: 1,
            damage: 3,
            type: "neutral", // keep in mind that they should be hostile
            ability: "nothing", // treant should have an ability
            lootDrop: spikeLootDrop,
            intelligence: 0,
            respawnTime: 8000
        };
		// spells
		const castSpike = {
			radius: 12,
			name: "castSpike",
			art: "projectile",
            shape: "circle",
            appearance: "spike.png",
			castAmount: 1,
            maxAmount: 0,
            ignoreSpellCollision: false,
            ignoreMobCollision: false,
            index: 1,
			health: 5,
            defense: 0,
            damage: 3,
            speed: 10,
            ability: "shoot1",
            manaCost: 0.1,
            respawnTime: 500
		};
		const castLuminousEnergy = {
            radius: 5,
			name: "castLuminousEnergy",
			art: "projecting",
            shape: "circle",
            appearance: "luminousRock.png",
            castAmount: 5,
            maxAmount: 5,
            ignoreSpellCollision: false,
            ignoreMobCollision: false,
            index: 1,
            health: 5,
            defense: 0,
            damage: 1,
            speed: 15,
            ability: "shoot2",
            manaCost: 1.25,
            respawnTime: 1000
		}
		const summonSpirit = {
			radius: 15,
			name: "summonSpirit",
			art: "summoning",
            shape: "circle",
            appearance: "luminousSpirit.png",
			castAmount: 8,
			maxAmount: 8,
            ignoreSpellCollision: false,
            ignoreMobCollision: false,
			index: 1,
			health: 10,
            defense: 0,
			damage: 3,
			speed: 5,
			ability: "summon1",
			manaCost: 1.75,
			respawnTime: 1000
		};
		const summonSpecter = {
			radius: 15,
			name: "summonSpecter",
			art: "summoning",
            shape: "circle",
            appearance: "specter.png",
			castAmount: 5,
			maxAmount: 5,
            ignoreSpellCollision: false,
            ignoreMobCollision: false,
			index: 1,
			health: 15,
			defense: 0,
			damage: 3,
			speed: 7,
			ability: "summon1",
			manaCost: 2.5,
			respawnTime: 1500
		};
		const teleport = {
			radius: 12,
			name: "teleport",
			art: "evading",
            shape: "circle",
            appearance: "teleportation.png",
			castAmount: 1,
			maxAmount: 0,
            ignoreSpellCollision: true,
            ignoreMobCollision: true,
			index: 1,
			health: 15,
            defense: 0,
			damage: 0,
			speed: 15,
			ability: "teleport",
			manaCost: 2,
			respawnTime: 500
		};
		const smash = {
			radius: 30,
			name: "smash",
			art: "AoE",
            shape: "circle",
            appearance: "smash.png",
			castAmount: 15,
			maxAmount: 0,
            ignoreSpellCollision: true,
            ignoreMobCollision: false,
			index: 1,
			health: 1,
            defense: 0,
			damage: 2.5,
			speed: 0,
			ability: "AoE1",
			manaCost: 3,
			respawnTime: 500
		};
        const castBeam = {
            radius: 0,
			name: "castBeam",
			art: "beams",
            shape: "line",
            appearance: "beam.webp",
            castAmount: 1,
            maxAmount: 0,
            ignoreSpellCollision: true,
            ignoreMobCollision: true,
            index: 1,
            health: 10000,
            defense: 0,
            damage: 0.5,
            speed: 10,
            ability: "beam1",
            manaCost: 1,
            respawnTime: 500
		};
        const castLightningBolt = {
            radius: 0,
            name: "castLightningBolt",
            art: "beams",
            shape: "line",
            appearance: "lightningBolt.png",
            castAmount: 5,
            maxAmount: 0,
            ignoreSpellCollision: true,
            ignoreMobCollision: true,
            index: 1,
            health: 100,
            defense: 0,
            damage: 3,
            speed: 10,
            ability: "beam2",
            manaCost: 2,
            respawnTime: 500
		};
        const castEnergyBall = {
            radius: 450,
            name: "castEnergyBall",
            art: "projectile",
            shape: "circle",
            appearance: "energyBall.png",
            castAmount: 1,
            maxAmount: 0,
            ignoreSpellCollision: true,
            ignoreMobCollision: true,
            index: 1,
            health: 2500,
            defense: 0,
            damage: 3,
            speed: 10,
            ability: "shoot1",
            manaCost: 1,
            respawnTime: 500
        };
        // spell books 
		const spikeBook = {
			radius: 12,
			name: "spikeBook",
			art: "books",
            shape: "circle",
            appearance: "enchantedBook.png",
            castAmount: 1,
            maxAmount: 1,
			ignoreSpellCollision: false,
			ignoreMobCollision: true,
            index: 1,
			health: 100,
            defense: 100,
            damage: 0,
            speed: 12,
            ability: "book",
            manaCost: 1,
            respawnTime: null
		}
		const luminousEnergyBook = {
            radius: 12,
			name: "luminousEnergyBook",
			art: "books",
            shape: "circle",
            appearance: "enchantedBook.png",
            castAmount: 1,
            maxAmount: 1,
            ignoreSpellCollision: false,
            ignoreMobCollision: true,
            index: 1,
            health: 100,
            defense: 100,
            damage: 0,
            speed: 12,
            ability: "book",
            manaCost: 1,
            respawnTime: null
		}
        const luminousSpiritBook = {
            radius: 12,
			name: "luminousSpiritBook",
			art: "books",
            shape: "circle",
            appearance: "enchantedBook.png",
            castAmount: 1,
            maxAmount: 1,
            ignoreSpellCollision: false,
            ignoreMobCollision: true,
            index: 1,
            health: 100,
            defense: 100,
            damage: 0,
            speed: 12,
            ability: "book",
            manaCost: 1,
            respawnTime: null
		}
        const specterBook = {
            radius: 12,
			name: "specterBook",
			art: "books",
            shape: "circle",
            appearance: "enchantedBook.png",
            castAmount: 1,
            maxAmount: 1,
            ignoreSpellCollision: false,
            ignoreMobCollision: true,
            index: 1,
            health: 100,
            defense: 100,
            damage: 0,
            speed: 12,
            ability: "book",
            manaCost: 1,
            respawnTime: null
        }
        const teleportBook = {
            radius: 12,
			name: "teleportBook",
			art: "books",
            shape: "circle",
            appearance: "enchantedBook.png",
            castAmount: 1,
            maxAmount: 1,
            ignoreSpellCollision: false,
            ignoreMobCollision: true,
            index: 1,
            health: 100,
            defense: 100,
            damage: 0,
            speed: 12,
            ability: "book",
            manaCost: 1,
            respawnTime: null
        }
        const smashBook = {
            radius: 12,
			name: "smashBook",
			art: "books",
            shape: "circle",
            appearance: "enchantedBook.png",
            castAmount: 1,
            maxAmount: 1,
            ignoreSpellCollision: false,
            ignoreMobCollision: true,
            index: 1,
            health: 100,
            defense: 100,
            damage: 0,
            speed: 12,
            ability: "book",
            manaCost: 1,
            respawnTime: null
		}
        const beamBook = {
            radius: 12,
			name: "beamBook",
			art: "books",
            shape: "circle",
            appearance: "enchantedBook.png",
            castAmount: 1,
            maxAmount: 1,
            ignoreSpellCollision: false,
            ignoreMobCollision: true,
            index: 1,
            health: 100,
            defense: 100,
            damage: 0,
            speed: 12,
            ability: "book",
            manaCost: 1,
            respawnTime: null
		}
        const lightningBoltBook = {
            radius: 12,
            name: "lightningBoltBook",
            art: "books",
            shape: "circle",
            appearance: "enchantedBook.png",
            castAmount: 1,
            maxAmount: 1,
            ignoreSpellCollision: false,
            ignoreMobCollision: true,
            index: 1,
            health: 100,
            defense: 100,
            damage: 0,
            speed: 12,
            ability: "book",
            manaCost: 1,
            respawnTime: null
		}
        const energyBallBook = {
            radius: 12,
            name: "energyBallBook",
            art: "books",
            shape: "circle",
            appearance: "enchantedBook.png",
            castAmount: 1,
            maxAmount: 1,
            ignoreSpellCollision: false,
            ignoreMobCollision: true,
            index: 1,
            health: 100,
            defense: 100,
            damage: 0,
            speed: 12,
            ability: "book",
            manaCost: 1,
            respawnTime: null
        }
		var myGameArea = {
			canvas: document.getElementById("mycanvas"), // splice
			start: function () {
				this.context = this.canvas.getContext("2d");
				this.interval = setInterval(updateGameArea, 16.67);
			},
			clear: function () {
				this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
			},
			stop: function () {
				clearInterval(this.interval);
			}
		}
		window.addEventListener('click', function (e) {
			const rect = canvas.getBoundingClientRect();
			mouseClickX = e.clientX - rect.left;
			mouseClickY = e.clientY - rect.top;
			buttonsArray.forEach(button => {
				button.clickButton(mouseClickX, mouseClickY);
			});
			spellBooksArray.forEach(spellBook => {
				spellBook.clickButton(mouseClickX, mouseClickY);
			})
		});
		window.addEventListener('mousedown', (event) => {
			//console.log(event);
			isMouseDown = true;
			const rect = canvas.getBoundingClientRect();
			mouseX = event.clientX - rect.left;
			mouseY = event.clientY - rect.top;
			biome1.clickImage(biome1);
		});

		window.addEventListener('mouseup', () => {
			isMouseDown = false;
		});

		window.addEventListener('mousemove', (event) => {
			if (isMouseDown) {
				const rect = canvas.getBoundingClientRect();
				mouseX = event.clientX - rect.left;
				mouseY = event.clientY - rect.top;
			}
		});
		// Key down event listener
		window.addEventListener('keydown', (event) => {
			//console.log(event);
			if (event.code in keys) {
				keys[event.code] = true;
			}
		});

		// Key up event listener
		window.addEventListener('keyup', (event) => {
			if (event.code in keys) {
				keys[event.code] = false;
			}
		});
		function startGame() {
			castSpellTimeout = [];
			buttonsArray = [];
			spellBooksArray = [];
			spellsArray = [];
			mobsArray = [];
			lootsArray = [];
            inventoryArray = [];
			maxExperience = 20;
			biome1 = new Background(10, 10, 2500, 1000, "grayBG.png");
			myGameCharacter = new PlayableCharacter(300, 300, 20, 0, "smileyy.webp", false, false, 90, 0, 5, 0, 0, 0, 0.01, 1.0005);
			camera = new Camera(canvas.width, canvas.height);
			spawnLuminousRock();
			spawnLuminousSpirit();
			spawnSpecter();
			spawnDarkForestTree()
            spawnDarkForestTreant()
			myGameArea.start();
			buttonsKeeper();
			spellBooksKeeper();
			spellsKeeper();
			var mainMenuVariable = document.getElementById("mainMenu");
			if (mainMenuVariable) {
				mainMenuVariable.remove();
			}
		}
		function buttonsKeeper() {
			addButton(new Button(5, 5, 200, 50, [5], "#5fa7e5", "levelBarButton", "level: " + myGameCharacter.level));
			addButton(new Button(5, 60, 200, 50, [5], "#ffd15d", "experienceBarButton", "experience: " + myGameCharacter.experience));
			addButton(new Button(5, 115, 200, 50, [5], "#ff5d70", "healthBarButton", "health: " + myGameCharacter.health));
			addButton(new Button(5, 170, 200, 50, [5], "#dbcff8", "manaBarButton", "mana: " + myGameCharacter.mana));
            addButton(new Button(5, 225, 110, 50, [5], "#e3a04d", "inventoryButton", "inventory"));
		}
		function spellBooksKeeper() {
            addSpellBook(new SpellBook(500, 5, 1, 100, 100, [5], "black", "energyBall.png", "energyBallBook", castEnergyBall, energyBallBook, 15, "castEnergyBall"));
            addSpellBook(new SpellBook(605, 5, 2, 100, 100, [5], "black", "beam.webp", "beamBook", castBeam, beamBook, 15, "castBeam"));
			addSpellBook(new SpellBook(710, 5, 3, 100, 100, [5], "black", "spike.png", "castSpikeBook", castSpike, spikeBook, 90, "castSpike"));
            addSpellBook(new SpellBook(1340, 5, 9, 100, 100, [5], "black", "lightningBolt.png", "lightningBoltBook", castLightningBolt, lightningBoltBook, 15, "castLightningBolt"));
		}
		function spellsKeeper() {
		}
		function updateGameArea() {
			// always updating
            worldX = (mouseX / camera.zoom) + camera.x;
            worldY = (mouseY / camera.zoom) + camera.y;
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			myGameArea.context.canvas.width = window.innerWidth - 3;
			myGameArea.context.canvas.height = window.innerHeight - 3;
            //console.log(window.innerWidth / 2 + " " + window.innerHeight / 2);
			ctx.fillStyle = "gray";
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			camera.follow(myGameCharacter);
			ctx.save();
			camera.applyTransform(ctx)
			biome1.draw(ctx);
			mobsArray.forEach(mob => {
				mob.update();
				mob.newPos();
				mob.interact();
			});
			lootsArray.forEach(loot => {
				loot.draw();
			});
			spellsArray.forEach(spell => {
				spell.update();
			});
			myGameCharacter.playerNewPos();
			myGameCharacter.update();
			myGameCharacter.regenerateHealth();
			myGameCharacter.regenerateMana();
			updatePlayerPosition();
			ctx.restore();
			spellBooksArray.forEach(spellBook => {
				spellBook.update();
			});
			buttonsArray.forEach(button => {
				button.update();
				button.draw(ctx);
			});
			// player and mob collision
			if (playerCrashWith(myGameCharacter, mobsArray)) {
				myGameCharacter.playerNewPos();
			}
			// player and loot collision
			if (playerCollideWithLoot(myGameCharacter, lootsArray)) {
                myGameCharacter.playerNewPos();
			}
			// mob to mob collision
			if (crashWith(mobsArray, mobsArray)) {
				myGameCharacter.playerNewPos();
			}
			// hitting a basic mob
			if (crashWithSpell(spellsArray, mobsArray)) {
				myGameCharacter.playerNewPos();
			}
			//updates when moving
			else {
				myGameCharacter.playerNewPos();
			}
			myGameCharacter.movementX = 0;
			myGameCharacter.movementY = 0;
			myGameCharacter.moveAngle = 0;
			myGameCharacter.newSpeed = 0;

			function updatePlayerPosition() {
  
				if ((keys.KeyW || keys.ArrowUp) && (keys.KeyA || keys.ArrowLeft)) { // Up-Left
					myGameCharacter.angle = (1.75 * Math.PI);
                    myGameCharacter.newSpeed = myGameCharacter.speed;
				} else if ((keys.KeyW || keys.ArrowUp) && (keys.KeyD || keys.ArrowRight)) { // Up-Right
					myGameCharacter.angle = (2.25 * Math.PI);
                    myGameCharacter.newSpeed = myGameCharacter.speed;
				} else if ((keys.KeyS || keys.ArrowDown) && (keys.KeyA || keys.ArrowLeft)) { // Down-Left
					myGameCharacter.angle = (1.25 * Math.PI);
                    myGameCharacter.newSpeed = myGameCharacter.speed;
				} else if ((keys.KeyS || keys.ArrowDown) && (keys.KeyD || keys.ArrowRight)) { // Down-Right
					myGameCharacter.angle = (0.75 * Math.PI);
                    myGameCharacter.newSpeed = myGameCharacter.speed;
				} else if (keys.KeyW || keys.ArrowUp) { // Up
					myGameCharacter.angle = (2 * Math.PI);
                    myGameCharacter.newSpeed = myGameCharacter.speed;
				} else if (keys.KeyS || keys.ArrowDown) { // Down
					myGameCharacter.angle = (1 * Math.PI);
                    myGameCharacter.newSpeed = myGameCharacter.speed;
				} else if (keys.KeyA || keys.ArrowLeft) { // Left
					myGameCharacter.angle = (1.5 * Math.PI);
                    myGameCharacter.newSpeed = myGameCharacter.speed;
				} else if (keys.KeyD || keys.ArrowRight) { // Right
					myGameCharacter.angle = (0.5 * Math.PI);
                    myGameCharacter.newSpeed = myGameCharacter.speed;
				}
			}
		}
		function playerDeath() {
			alert("game over");
			myGameArea.stop();
			castSpellTimeout = [];
			buttonsArray = [];
			spellBooksArray = [];
			spellsArray = [];
			mobsArray = [];
			lootsArray = [];
			inventoryArray = [];
            slot3Active = false;
            slot4Active = false;
            slot5Active = false;
            slot6Active = false;
            slot7Active = false;
            slot8Active = false;
            slot9Active = false;
			startGame();
		}
		function levelUp() {
			if (myGameCharacter.experience >= maxExperience) {
				do {
                    myGameCharacter.experience -= maxExperience;
                    maxExperience += 20;
                    myGameCharacter.level += 1;
                    myGameCharacter.maxHealth += 5;
                    myGameCharacter.maxMana += 1;
					myGameCharacter.manaRegen += 0.00025;
					
                    if (!slot4Active && myGameCharacter.level >= 1) {
                        addSpellBook(new SpellBook(815, 5, 4, 100, 100, [5], "black", "luminousSpirit.png", "summonSpiritBook", summonSpirit, luminousSpiritBook, 300, "summonSpirit"));
						slot4Active = true;
					}
                    if (!slot5Active && myGameCharacter.level >= 1) {
                        addSpellBook(new SpellBook(920, 5, 5, 100, 100, [5], "black", "luminousRock.png", "castLuminousEnergyBook", castLuminousEnergy, luminousEnergyBook, 45, "castLuminousEnergy"));
                        slot5Active = true;
					}
                    if (!slot6Active && myGameCharacter.level >= 2) {
                        addSpellBook(new SpellBook(1025, 5, 6, 100, 100, [5], "black", "specter.png", "summonSpecterBook", summonSpecter, specterBook, 420, "summonSpecter"));
                        slot6Active = true;
					}
                    if (!slot7Active && myGameCharacter.level >= 2) {
                        addSpellBook(new SpellBook(1130, 5, 7, 100, 100, [5], "black", "teleportation.png", "teleportBook", teleport, teleportBook, 180, "teleport"));
                        slot7Active = true;
					}
                    if (!slot8Active && myGameCharacter.level >= 3) {
                        addSpellBook(new SpellBook(1235, 5, 8, 100, 100, [5], "black", "smash.png", "smashBook", smash, smashBook, 15, "smash"));
                        slot8Active = true;
					}
                //    if (!slot9Active && myGameCharacter.level >= 4) {
                //        addSpellBook(new SpellBook(1340, 5, 9, 100, 100, [5], "black", "lightningBolt.png", "lightningBoltBook", castLightningBolt, lightningBoltBook, 15, "castLightningBolt"));
                //        slot9Active = true;
                //    }
                }
                while (myGameCharacter.experience >= maxExperience);
			}
		}
		function addButton(button) {
			let newButton = new Button(button.x, button.y, button.width, button.height, button.radii, button.color, button.name, button.text);
			buttonsArray.push(newButton);
		}
		function addSpellBook(spellBook) {
            let newSpellBook = new SpellBook(spellBook.x, spellBook.y, spellBook.index, spellBook.width, spellBook.height, spellBook.radii, spellBook.borderColor, spellBook.appearance, spellBook.name, spellBook.spell, spellBook.mainSpellBook, spellBook.cooldown, spellBook.text)
			spellBooksArray.push(newSpellBook);
		}
        function dropLoot(loot) {
			let newLoot = new Loot(loot.x, loot.y, loot.radius, loot.name, loot.spellName, loot.appearance, loot.ignoreCollision, loot.text)
			lootsArray.push(newLoot);
        }
		function castSpell(spell) {
			let newSpell = new Spell(
				spell.x,
				spell.y,
				spell.radius,
				spell.name,
				spell.art,
				spell.shape,
				spell.appearance,
				spell.castAmount,
				spell.maxAmount,
                spell.ignoreSpellCollision,
                spell.ignoreMobCollision,
				spell.positionIndex,
				spell.health,
				spell.defense,
				spell.damage,
				spell.speed,
				spell.ability,
				spell.manaCost,
				spell.respawnTime);
			spellsArray.push(newSpell);
		}
		function spawnLuminousRock() {
			for (let i = 0; i < luminousRock.maxAmount; i++) {
				let luminousRockRandomX = (((biome1.x - camera.x) + (Math.floor((Math.random() * (2000 - 10 + 1)) + 10))) / camera.zoom) + camera.x;
				let luminousRockRandomY = (((biome1.y - camera.y) + (Math.floor((Math.random() * (1000 - 10 + 1)) + 10))) / camera.zoom) + camera.y;
				let luminousRockRandomRadiusXHealth = Math.floor((Math.random() * (70 - 20 + 1)) + 20);
				let luminousRockRandomExperienceDrop = Math.floor((Math.random() * (15 - 10 + 1)) + 10);
				let newLuminousRock = new LuminousRock(
					luminousRockRandomX,
					luminousRockRandomY,
					luminousRockRandomRadiusXHealth,
                    luminousRock.radiusAdjust,
					luminousRock.appearance,
					luminousRock.ignoreSpellCollision,
                    luminousRock.ignoreMobCollision,
					luminousRockRandomRadiusXHealth,
                    luminousRock.defense,
					luminousRock.damage,
					luminousRock.mobName,
					luminousRock.type,
					luminousRock.ability,
					luminousRock.intelligence,
					luminousRockRandomExperienceDrop,
					luminousRock.lootDrop, 0, 0);
				mobsArray.push(newLuminousRock);
			}
		}
		function spawnLuminousSpirit() {
			for (let i = 0; i < luminousSpirit.maxAmount; i++) {
				let luminousSpiritRandomX = (((biome1.x - camera.x) + (Math.floor((Math.random() * (2500 - 1000 + 1)) + 1000))) / camera.zoom) + camera.x;
				let luminousSpiritRandomY = (((biome1.y - camera.y) + (Math.floor((Math.random() * (1000 - 10 + 1)) + 10))) / camera.zoom) + camera.y;
				let luminousSpiritRandomRadiusXHealth = Math.floor((Math.random() * (70 - 25 + 1)) + 25);
				let luminousSpiritRandomExperienceDrop = Math.floor((Math.random() * (20 - 15 + 1)) + 15);
				let newLuminousSpirit = new LuminousSpirit(
					luminousSpiritRandomX,
					luminousSpiritRandomY,
					luminousSpiritRandomRadiusXHealth,
                    luminousSpirit.radiusAdjust,
					luminousSpirit.appearance,
					luminousSpirit.ignoreSpellCollision,
                    luminousSpirit.ignoreMobCollision,
					luminousSpiritRandomRadiusXHealth,
                    luminousSpirit.defense,
					luminousSpirit.damage,
					luminousSpirit.mobName,
					luminousSpirit.type,
					luminousSpirit.ability,
					luminousSpirit.intelligence,
					luminousSpiritRandomExperienceDrop,
					luminousSpirit.lootDrop, 0, 0);
				mobsArray.push(newLuminousSpirit);
				//console.log(mobsArray);
			}
		}
		function spawnSpecter() {
			for (let i = 0; i < specter.maxAmount; i++) {
				let specterRandomX = (((biome1.x - camera.x) + (Math.floor((Math.random() * (2500 - 1500 + 1)) + 1500))) / camera.zoom) + camera.x;
				let specterRandomY = (((biome1.y - camera.y) + (Math.floor((Math.random() * (1000 - 10 + 1)) + 10))) / camera.zoom) + camera.y;
				let specterRandomRadiusXHealth = Math.floor((Math.random() * (80 - 25 + 1)) + 25);
				let specterRandomExperienceDrop = Math.floor((Math.random() * (30 - 20 + 1)) + 20);
				let newSpecter = new Specter(
					specterRandomX,
					specterRandomY,
					specterRandomRadiusXHealth,
                    specter.radiusAdjust,
					specter.appearance,
					specter.ignoreSpellCollision,
                    specter.ignoreMobCollision,
					specterRandomRadiusXHealth,
                    specter.defense,
					specter.damage,
					specter.mobName,
					specter.type,
					specter.ability,
					specter.intelligence,
					specterRandomExperienceDrop,
					specter.lootDrop,
					0, 0);
				mobsArray.push(newSpecter);
			}
		}
        function spawnDarkForestTree() {
            for (let i = 0; i < darkForestTree.maxAmount; i++) {
                let darkForestTreeRandomX = (((biome1.x - camera.x) + (Math.floor((Math.random() * (2000 - 10 + 1)) + 10))) / camera.zoom) + camera.x;
                let darkForestTreeRandomY = (((biome1.y - camera.y) + (Math.floor((Math.random() * (1000 - 10 + 1)) + 10))) / camera.zoom) + camera.y;
                let darkForestTreeRandomRadiusXHealth = Math.floor((Math.random() * (70 - 20 + 1)) + 20);
                let darkForestTreeRandomExperienceDrop = Math.floor((Math.random() * (20 - 15 + 1)) + 15);
                let newDarkForestTree = new DarkForestTree(
                    darkForestTreeRandomX,
                    darkForestTreeRandomY,
                    darkForestTreeRandomRadiusXHealth,
                    darkForestTree.radiusAdjust,
                    darkForestTree.appearance,
                    darkForestTree.ignoreSpellCollision,
                    darkForestTree.ignoreMobCollision,
                    darkForestTreeRandomRadiusXHealth,
                    darkForestTree.defense,
                    darkForestTree.damage,
                    darkForestTree.mobName,
                    darkForestTree.type,
                    darkForestTree.ability,
                    darkForestTree.intelligence,
                    darkForestTreeRandomExperienceDrop,
                    darkForestTree.lootDrop, 0, 0);
                mobsArray.push(newDarkForestTree);
            }
		}
        function spawnDarkForestTreant() {
            for (let i = 0; i < darkForestTreant.maxAmount; i++) {
                let darkForestTreantRandomX = (((biome1.x - camera.x) + (Math.floor((Math.random() * (2000 - 10 + 1)) + 10))) / camera.zoom) + camera.x;
                let darkForestTreantRandomY = (((biome1.y - camera.y) + (Math.floor((Math.random() * (1000 - 10 + 1)) + 10))) / camera.zoom) + camera.y;
                let darkForestTreantRandomRadiusXHealth = Math.floor((Math.random() * (70 - 20 + 1)) + 20);
                let darkForestTreantRandomExperienceDrop = Math.floor((Math.random() * (30 - 20 + 1)) + 20);
                let newDarkForestTreant = new DarkForestTreant(
                    darkForestTreantRandomX,
                    darkForestTreantRandomY,
                    darkForestTreantRandomRadiusXHealth,
                    darkForestTreant.radiusAdjust,
                    darkForestTreant.appearance,
                    darkForestTreant.ignoreSpellCollision,
                    darkForestTreant.ignoreMobCollision,
                    darkForestTreantRandomRadiusXHealth,
                    darkForestTreant.defense,
                    darkForestTreant.damage,
                    darkForestTreant.mobName,
                    darkForestTreant.type,
                    darkForestTreant.ability,
                    darkForestTreant.intelligence,
                    darkForestTreantRandomExperienceDrop,
                    darkForestTreant.lootDrop, 0, 0);
                mobsArray.push(newDarkForestTreant);
            }
        }
		function crashWith(mob1Array, mob2Array) {
			let result = false;
			mob1Array.forEach(mob1 => {
				mob2Array.forEach(mob2 => {
					let radii = mob1.radius + mob2.radius;
					let distance = getDistance(mob1, mob2);
					let hasCrashed = distance < radii;
					if (hasCrashed) {
						result = hasCrashed;
						const dx = mob2.x - mob1.x;
						const dy = mob2.y - mob1.y;
						const distance = Math.sqrt(dx * dx + dy * dy);
						const minDistance = mob1.radius + mob2.radius;
						if (distance < minDistance) {
							// Calculate knockback direction
							const angle = Math.atan2(dy, dx);
							const knockbackDistance = 1;
							// Apply knockback
							for (let i = 0; i < 5; i++) {
								if (!mob1.ignoreMobCollision) {
									mob1.x -= Math.cos(angle) * knockbackDistance;
									mob1.y -= Math.sin(angle) * knockbackDistance;
								} if (!mob2.ignoreMobCollision) {
									mob2.x += Math.cos(angle) * knockbackDistance;
									mob2.y += Math.sin(angle) * knockbackDistance;
								}
							}
						}
					}
				});
			});
			return result;
		}
        function playerCollideWithLoot(mob1, lootsArray) {
            let result = false;
            lootsArray.forEach(loot => {
                let radii = (mob1.radius + 200) + loot.radius; // temporary magnet for loot
                let distance = getDistance(mob1, loot);
                let hasCrashed = distance < radii;
                if (hasCrashed) {
                    result = hasCrashed;
					let lootIndex = lootsArray.indexOf(loot);
					inventoryArray.push(loot);
                    lootsArray.splice(lootIndex, 1);
                }
            });
            return result;
		}
		function playerCrashWith(mob1, mob2Array) {
			let result = false;
			mob2Array.forEach(mob2 => {
				let radii = mob1.radius + mob2.radius;
				let distance = getDistance(mob1, mob2);
				let hasCrashed = distance < radii;
				if (hasCrashed) {
					result = hasCrashed;
					const dx = mob2.x - mob1.x;
					const dy = mob2.y - mob1.y;
                    // Calculate knockback direction
					const angle = Math.atan2(dy, dx);
					const knockbackDistance = 1;
					// Apply knockback
					for (let i = 0; i < 7; i++) {
						if (!mob1.ignoreMobCollision) {
							mob1.x -= Math.cos(angle) * knockbackDistance;
							mob1.y -= Math.sin(angle) * knockbackDistance;
						}
						if (!mob2.ignoreMobCollision) {
							mob2.x += Math.cos(angle) * knockbackDistance;
							mob2.y += Math.sin(angle) * knockbackDistance;
						}
					}
                    // Calculate mob 2 damage
                    let calculatedMob2Damage = Math.max(0, mob2.damage - mob1.defense);
                    mob1.health = Math.max(0, mob1.health - calculatedMob2Damage);

                    // Calculate mob 1 damage
                    let calculatedMob1Damage = Math.max(0, mob1.damage - mob2.defense);
                    mob2.health = Math.max(0, mob2.health - calculatedMob1Damage);
					mob2.radius = mob2.health;
                    myGameCharacter.health = mob1.health;
					// player to mob collision
					if (myGameCharacter.health <= 0) {
						//death
						playerDeath();
					}
				}
			});
			return result;
		}
        function crashWithSpell(spellsArray, mobArray) {
            let result = false;
            spellsArray.forEach(spell => {
                let totalDamageDealt = false; // Track if the spell has dealt any damage to any mob
				for (let mobIndex = 0; mobIndex < mobArray.length; mobIndex++) {
					let mob = mobArray[mobIndex];
					if (spell.shape == "circle") { 
					let radii = spell.radius + mob.radius;
					let distance = getDistance(spell, mob);
						let hasCrashed = distance < radii;
						if (hasCrashed) {
							simulateCollision();
						}
					}
					if (spell.shape == "line") {
                        // Calculate the closest point on the line segment to the circle center
                        const lineStart = { x: spell.x, y: spell.y };
                        const lineEnd = { x: spell.x2, y: spell.y2 };
                        const circleCenter = { x: mob.x, y: mob.y };

                        // Vector from line start to circle center
                        const lineToCircle = {
                            x: circleCenter.x - lineStart.x,
                            y: circleCenter.y - lineStart.y
                        };

                        // Line segment vector
                        const lineVector = {
                            x: lineEnd.x - lineStart.x,
                            y: lineEnd.y - lineStart.y
                        };

                        // Calculate projection of lineToCircle onto lineVector
                        const lineLengthSquared = lineVector.x * lineVector.x + lineVector.y * lineVector.y;
                        let t = ((lineToCircle.x * lineVector.x) + (lineToCircle.y * lineVector.y)) / lineLengthSquared;

                        // Clamp t to stay within the segment bounds
                        t = Math.max(0, Math.min(1, t));

                        // Find the closest point on the line segment
                        const closestPoint = {
                            x: lineStart.x + t * lineVector.x,
                            y: lineStart.y + t * lineVector.y
                        };

                        // Distance from circle center to closest point
                        const dx = closestPoint.x - circleCenter.x;
                        const dy = closestPoint.y - circleCenter.y;
						const distance = Math.sqrt(dx * dx + dy * dy);

						if (distance < mob.radius) {
							simulateCollision();
						}
					}
					function simulateCollision() {
                        result = true;
                        totalDamageDealt = true;

                        // Apply damage to the mob
						let calculatedSpellDamage = spell.damage - mob.defense;
                        if (calculatedSpellDamage <= 0) {
                            calculatedSpellDamage = 0;
                        }
                        mob.health -= calculatedSpellDamage;
                        mob.radius = mob.health;
                        let calculatedMobDamage = mob.damage - spell.defense;
                        if (calculatedMobDamage <= 0) {
                            calculatedMobDamage = 0;
                        }
                        // Apply damage to the spell
                        if (spell.ability !== "book") {
                            spell.health -= calculatedMobDamage;
                        }

                        // Check if the mob should die and be removed
                        if (mob.health <= 15) {
                            myGameCharacter.experience += mob.experienceDrop;
                            levelUp();
                            mob.spawn();
                            mob.die();
                            mobArray.splice(mobIndex, 1);
                            mobIndex--; // Adjust index after removal
                        }

                        // Apply knockback to both spell and mob
                        const dx = mob.x - spell.x;
                        const dy = mob.y - spell.y;
                        const angle = Math.atan2(dy, dx);
                        const knockbackDistance = 2;

						if (spell.ability !== "book") {
							if (!spell.ignoreMobCollision) {
								spell.x -= Math.cos(angle) * knockbackDistance;
								spell.y -= Math.sin(angle) * knockbackDistance;
							}
							if (!mob.ignoreSpellCollision) {
								mob.x += Math.cos(angle) * knockbackDistance;
								mob.y += Math.sin(angle) * knockbackDistance;
							}
						}
                    }
                }

                // Remove the spell only if its health is <= 0 after damaging all mobs
                if (totalDamageDealt && spell.health <= 0) {
                    let spellIndex = spellsArray.indexOf(spell);
                    spellsArray.splice(spellIndex, 1);
                }
            });
            return result;
        }
		function getDistance(circle1, circle2) {
			let a = circle2.y - circle1.y;
			let b = circle2.x - circle1.x;
			return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
		}
		/*
		tasks:
		7). add upgrades points. you can earn ugrade points when killing mobs or when leveling up
		12). add a way to access spell books in game
		13). add a notification type of feature when a skill is used to show when player has insufficient mana
		15).
		1000). add a place where npcs will go to when their kingdom is invaded
		1001). most people arent allowed to go to that place because that place is only for emergencies and they cant risk it getting invaded
		1002). make npcs killable (someone rich and willing needs to resurect them) (there will be a sign that says theyve been killed or something)
		1003). squads/teams will be a thing where friends can play together
		1004). there should be a local gamemode so people can still have fun
		1005). only add some ads
		1006). ranks should be a thing
		1007). a spellBook that progressively gets stronger the more mobs you kill

		game issues to fix:
		bug 2 is fixed. but im not removing it because it has existed for years and only got removed today 17/10/2024 3:37 AM
		2). the spell book issue happens when a spell book hits 2 basic mob at the same time because the crashWith function is called twice and deletes 2 spellbooks.
		3). the spell, when hitting 2 or more mobs at the same time, it chooses a random mob to damage rather than having both of them damaged.
		    maybe make it so that the closest mob to the spells' center is the prioritized mob to get damaged.
		*/
	</script>
</body>
</html>
