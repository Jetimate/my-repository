<!DOCTYPE html>
<html>
<head>
	<title>Spelz.io</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
		html, body {
			height: 100%;
			margin: 0;
		}
        #mycanvas {
            border: 1px solid #d3d3d3;
            background-color: #f1f1f1;
            position: absolute;
            z-index: -1;
        }
	</style>
</head>
<body>
	<canvas id="mycanvas"></canvas>
	<script type="text/javascript" src="js/globalUtilities.js"></script>
	<script type="text/javascript" src="js/mob.js"></script>
	<script type="text/javascript" src="js/playableCharacter.js"></script>
	<script type="text/javascript" src="js/spellBook.js"></script>
	<script type="text/javascript" src="js/spell.js"></script>
	<script type="text/javascript" src="js/button.js"></script>
	<script type="text/javascript" src="js/background.js"></script>
	<script type="text/javascript" src="js/camera.js"></script>
	<script type="text/javascript" src="js/libraries/spellBooksLibrary.js"></script>

	<script type="text/javascript" src="js/libraries/lootDropLibrary.js"></script>
	<script type="text/javascript" src="js/loot.js"></script>
	<script type="text/javascript" src="js/libraries/mobLibrary.js"></script>

	<script>
		/*
		reminders when working on this game:
		1. always commit all and push to github before trying something new
		*/
		const starterMobsArray = [
			luminousRock,
			luminousSpirit,
			specter,
			gloomForestTree,
			gloomForestTreant,
			gloomForestSpecterTreant,
			luminousSpiritTreant,
			wanderingFog,
			zapper];

		document.addEventListener("DOMContentLoaded", function () {
			myGame.start();
			resizeCanvas();
		});

		function mainMenu() {

		}

		function startGame() {
			castSpellTimeout = [];
			buttonsArray = [];
			spellBooksArray = [];
			spellsArray = [];
			mobsArray = [];
			lootsArray = [];
			inventoryArray = [];
			// ------- for debug, delete later
            addLootToInventory(spikePage, 64);
			addLootToInventory(gloomEssence, 64);
			// -------
			biome1 = new Background(10, 10, 10000, 10000, "grayBG.png");
			myGameCharacter = new PlayableCharacter(5000, 5000, 5000, 5000, 5000, 5000, "mob/player.svg", false, false, 100, 0.5, 1, 20, 0, "player1", 10, 0, 0, 0.01, 0.005); //mana regen = 0.0005, mana = 5
			camera = new Camera(canvas.width, canvas.height);
			spawnMobs();
			buttonsKeeper();
			spellBooksKeeper();
			spellsKeeper();
			var mainMenuVariable = document.getElementById("mainMenu");
			if (mainMenuVariable) {
				mainMenuVariable.remove();
			}
		}

		function buttonsKeeper() {
            // stats bar
			addButton(buttonLibrary.levelBar, 0);
			addButton(buttonLibrary.experienceBar, 1);
			addButton(buttonLibrary.healthBar, 2);
			addButton(buttonLibrary.manaBar, 3);
            // clickable buttons
			addButton(buttonLibrary.inventoryButton, null);
            addButton(buttonLibrary.settingsButton, null);

            addButton(buttonLibrary.spellBookSlot, 1);
            addButton(buttonLibrary.spellBookSlot, 2);
            addButton(buttonLibrary.spellBookSlot, 3);
            addButton(buttonLibrary.spellBookSlot, 4);
		}
		function spellBooksKeeper() {
			//below this comment is the primary spell
			
            addSpellBook(spikeBook, 1);
            addSpellBook(smashBook, 2);
            addSpellBook(luminousEnergyBook, 3);
			addSpellBook(glowShardBook, 4);

            addSpellBook(energyBallBook, null);
            addSpellBook(specterBook, null);
            addSpellBook(teleportBook, null);
            addSpellBook(lightningBoltBook, null);
            addSpellBook(specterHandBook, null);
            addSpellBook(treeBook, null);
		}
		function spellsKeeper() {
		}

        function updateCanvas() {
            if (resizePending) {
                resizeCanvas();
                resizePending = false;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "gray";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (gameplayScreen) {
                if (!gameStarted) {
                    startGame();
                    gameStarted = true;
                }
                updateGameplayScreen();
            }

            requestAnimationFrame(updateCanvas);
        }
		function resizeCanvas() {
			
            const canvas = myGame.canvas;
            const newWidth = window.innerWidth - 3;
            const newHeight = window.innerHeight - 3;

            if (canvas.width !== newWidth || canvas.height !== newHeight) {
                canvas.width = newWidth;
                canvas.height = newHeight;
			}

            statsBarX = window.innerWidth * 0.004;
            statsBarY = window.innerHeight * 0.008;
            statsBarWidth = ((screen.width * 0.6) + (window.innerWidth * 0.4)) / 8;
            statsBarHeight = ((screen.height * 0.6) + (window.innerHeight * 0.4)) / 24;
        }

		function updateGameplayScreen() {
			console.log(manaBuildUp, myGameCharacter.mana);
			// Calculate world coordinates
			worldX = (mouseX / camera.zoom) + camera.x;
			worldY = (mouseY / camera.zoom) + camera.y;

			// Update camera to follow the player
			camera.follow(myGameCharacter, myGame.context.canvas.width, myGame.context.canvas.height);
            camera.applyTransform(ctx);  
            // Draw game objects
			biome1.draw(ctx);
			mobsArray.forEach(mob => {
				mob.draw(ctx);
				mob.newPos();
				mob.interact();
			});
			lootsArray.forEach(loot => loot.draw(ctx));
			spellsArray.forEach(spell => spell.update());
			myGameCharacter.draw(ctx);
			myGameCharacter.regenerateHealth();
			myGameCharacter.regenerateMana();
			updatePlayerPosition();

            // Reset transformations (important!!!)
            camera.resetTransform(ctx);

			buttonsArray.forEach(button => {
				button.draw(ctx);
			});
			spellBooksArray.forEach(spellBook => {
				spellBook.update();
			});

			// player and mob collision
			playerCrashWith(myGameCharacter, mobsArray);
			// player and loot collision
			playerCollideWithLoot(myGameCharacter, lootsArray);
			// player and spell collision
			playerCrashWithSpell(myGameCharacter, spellsArray);
			// mob to mob collision
			crashWith(mobsArray, mobsArray);
			// mob and spell collision
			crashWithSpell(spellsArray, mobsArray);
			myGameCharacter.playerNewPos();
			myGameCharacter.movementX = 0;
			myGameCharacter.movementY = 0;
			myGameCharacter.moveAngle = 0;
			myGameCharacter.newSpeed = 0;

			function updatePlayerPosition() {
				if (keyMovement) {
					if ((keys.KeyW || keys.ArrowUp) && (keys.KeyA || keys.ArrowLeft)) { // Up-Left
						myGameCharacter.angle = (1.75 * Math.PI);
						myGameCharacter.newSpeed = myGameCharacter.speed;
					} else if ((keys.KeyW || keys.ArrowUp) && (keys.KeyD || keys.ArrowRight)) { // Up-Right
						myGameCharacter.angle = (2.25 * Math.PI);
						myGameCharacter.newSpeed = myGameCharacter.speed;
					} else if ((keys.KeyS || keys.ArrowDown) && (keys.KeyA || keys.ArrowLeft)) { // Down-Left
						myGameCharacter.angle = (1.25 * Math.PI);
						myGameCharacter.newSpeed = myGameCharacter.speed;
					} else if ((keys.KeyS || keys.ArrowDown) && (keys.KeyD || keys.ArrowRight)) { // Down-Right
						myGameCharacter.angle = (0.75 * Math.PI);
						myGameCharacter.newSpeed = myGameCharacter.speed;
					} else if (keys.KeyW || keys.ArrowUp) { // Up
						myGameCharacter.angle = (2 * Math.PI);
						myGameCharacter.newSpeed = myGameCharacter.speed;
					} else if (keys.KeyS || keys.ArrowDown) { // Down
						myGameCharacter.angle = (1 * Math.PI);
						myGameCharacter.newSpeed = myGameCharacter.speed;
					} else if (keys.KeyA || keys.ArrowLeft) { // Left
						myGameCharacter.angle = (1.5 * Math.PI);
						myGameCharacter.newSpeed = myGameCharacter.speed;
					} else if (keys.KeyD || keys.ArrowRight) { // Right
						myGameCharacter.angle = (0.5 * Math.PI);
						myGameCharacter.newSpeed = myGameCharacter.speed;
					}
				}
				if (mouseMovement) {
					if (myGameCharacter.hasTarget && playerTargetX != null && playerTargetY != null) {
						// Calculate the difference in x and y between the current position and the target
						let dx = playerTargetX - myGameCharacter.x;
						let dy = playerTargetY - myGameCharacter.y;

						// Calculate the distance to the target
						let distance = Math.sqrt(dx * dx + dy * dy);

						myGameCharacter.newSpeed = myGameCharacter.speed;

						// Check if the character has reached the target
						if (distance <= myGameCharacter.newSpeed) {
							// Snap to target and stop moving
							myGameCharacter.x = playerTargetX;
							myGameCharacter.y = playerTargetY;
							playerTargetX = null;
							playerTargetY = null;
							myGameCharacter.hasTarget = false;
						} else {
							// Calculate the angle to the target
							myGameCharacter.angle = Math.atan2(dy, dx) - (1.5 * Math.PI);

							// Move toward the target
							myGameCharacter.x += myGameCharacter.newSpeed * Math.sin(myGameCharacter.angle);
							myGameCharacter.y -= myGameCharacter.newSpeed * Math.cos(myGameCharacter.angle);
							if (myGameCharacter.x < myGameCharacter.radius) myGameCharacter.x = myGameCharacter.radius;
							if (myGameCharacter.x > biome1.width - myGameCharacter.radius) myGameCharacter.x = biome1.width - myGameCharacter.radius;
							if (myGameCharacter.y < myGameCharacter.radius) myGameCharacter.y = myGameCharacter.radius;
							if (myGameCharacter.y > biome1.height - myGameCharacter.radius) myGameCharacter.y = biome1.height - myGameCharacter.radius;
						}
					}
				}
				if (followMouseMovement) {
					let castMouseX = worldX - biome1.x;
					let castMouseY = worldY - biome1.y;
					let dx = castMouseX - myGameCharacter.x;
					let dy = castMouseY - myGameCharacter.y;

					myGameCharacter.angle = Math.atan2(dy, dx) - (1.5 * Math.PI);

					if (keys.KeyW || keys.ArrowUp) {
						myGameCharacter.newSpeed = myGameCharacter.speed;

						myGameCharacter.x += myGameCharacter.newSpeed * Math.sin(myGameCharacter.angle);
						myGameCharacter.y -= myGameCharacter.newSpeed * Math.cos(myGameCharacter.angle);
						if (myGameCharacter.x < myGameCharacter.radius) myGameCharacter.x = myGameCharacter.radius;
						if (myGameCharacter.x > biome1.width - myGameCharacter.radius) myGameCharacter.x = biome1.width - myGameCharacter.radius;
						if (myGameCharacter.y < myGameCharacter.radius) myGameCharacter.y = myGameCharacter.radius;
						if (myGameCharacter.y > biome1.height - myGameCharacter.radius) myGameCharacter.y = biome1.height - myGameCharacter.radius;

					}
				}
			}
		}
		function playerDeath() {
			alert("game over");
			myGame.stop();
			castSpellTimeout = [];
			buttonsArray = [];
			spellBooksArray = [];
			spellsArray = [];
			mobsArray = [];
			lootsArray = [];
			inventoryArray = [];
			toBeCraftedArray = [];
			startGame();
		}
		function levelUp() {
			if (myGameCharacter.experience >= maxExperience) {
				do {
					myGameCharacter.experience -= maxExperience;
					maxExperience += 100;
					myGameCharacter.level += 1;
					myGameCharacter.maxHealth += 5;
					myGameCharacter.maxMana += 1;
					myGameCharacter.manaRegen += 0.00025;
					myGameCharacter.summonLimit += 2.5;
					/*
					if (!slot4Active && myGameCharacter.level >= 1) {
						addSpellBook(new SpellBook(0, 0, null, 100, 100, [5], "black", "luminousSpirit.png", "summonSpiritBook", generateID(), summonSpirit, mainLuminousSpirit, 300, "Spirit"));
						slot4Active = true;
					}
					if (!slot5Active && myGameCharacter.level >= 1) {
						addSpellBook(new SpellBook(0, 0, null, 100, 100, [5], "black", "luminousRock.png", "castLuminousEnergyBook", generateID(), castLuminousEnergy, mainLuminousEnergy, 45, "Luminergy"));
						slot5Active = true;
					}
					if (!slot6Active && myGameCharacter.level >= 2) {
						addSpellBook(new SpellBook(0, 0, null, 100, 100, [5], "black", "specter.svg", "summonSpecterBook", generateID(), summonSpecter, mainSpecter, 300, "Specter"));
						slot6Active = true;
					}
					if (!slot7Active && myGameCharacter.level >= 2) {
						addSpellBook(new SpellBook(0, 0, null, 100, 100, [5], "black", "teleportation.png", "teleportBook", generateID(), teleport, mainTeleport, 180, "Teleport"));
						slot7Active = true;
					}
					if (!slot8Active && myGameCharacter.level >= 3) {
						addSpellBook(new SpellBook(0, 0, null, 100, 100, [5], "black", "smash.png", "smashBook", generateID(), smash, mainSmash, 15, "Smash"));
						slot8Active = true;
					}
					*/
					if (myGameCharacter.spellBookSlotsUnlocked < 5 && myGameCharacter.level >= 5) {
						myGameCharacter.spellBookSlotsUnlocked += 1;
                        addButton(buttonLibrary.spellBookSlot, 5);
						// add new spellBookSlot
					}
					if (myGameCharacter.spellBookSlotsUnlocked < 6 && myGameCharacter.level >= 15) {
						myGameCharacter.spellBookSlotsUnlocked += 1;
                        addButton(buttonLibrary.spellBookSlot, 6);
						// add new spellBookSlot
					}
					if (myGameCharacter.spellBookSlotsUnlocked < 7 && myGameCharacter.level >= 30) {
						myGameCharacter.spellBookSlotsUnlocked += 1;
                        addButton(buttonLibrary.spellBookSlot, 7);
						// add new spellBookSlot
					}
					if (myGameCharacter.spellBookSlotsUnlocked < 8 && myGameCharacter.level >= 45) {
						myGameCharacter.spellBookSlotsUnlocked += 1;
                        addButton(buttonLibrary.spellBookSlot, 8);
						// add new spellBookSlot
					}
					if (myGameCharacter.spellBookSlotsUnlocked < 9 && myGameCharacter.level >= 60) {
						myGameCharacter.spellBookSlotsUnlocked += 1;
                        addButton(buttonLibrary.spellBookSlot, 9);
						// add new spellBookSlot
					}
                    //console.log(myGameCharacter.spellBookSlotsUnlocked);
				}
				while (myGameCharacter.experience >= maxExperience);
			}
		}
        // add loot to inventory for debugging purposes
        function addLootToInventory(loot, amount) {
           let newLoot = new Loot(
              0, 0,
              loot.radius, loot.name, loot.spellBookName, loot.rarity,
              loot.dropChance, loot.appearance, loot.form, loot.type,
              loot.essenceName, loot.pagesToCraft, loot.essenceToCraft,
              loot.ignoreCollision, amount, loot.stackLimit, loot.text
           );
           inventoryArray.push(newLoot);
        }

		function addButton(button, index) {
            let newButton = new Button(button.x, button.y, button.width, button.height, button.radii, button.color, button.name, button.group, button.classification, button.text, index);
			buttonsArray.push(newButton);
		}
		function addSpellBook(spellBook, index) {
            let newSpellBook = new SpellBook(spellBook.x, spellBook.y, index, spellBook.width, spellBook.height, spellBook.radii, "black", spellBook.appearance, spellBook.name, generateID(), spellBook.spell, spellBook.spellCore, spellBook.cooldown, spellBook.text)
			let slotIndex = buttonsArray.findIndex(element => element.group === "spellBookSlot" && element.index == newSpellBook.index);
			if (newSpellBook.index != null && !buttonsArray[slotIndex].slotActive) {
				buttonsArray[slotIndex].slotActive = true;
				newSpellBook.onSlot = true;
				spellBooksArray.push(newSpellBook);
			} else {
				inventoryArray.push(newSpellBook);
			}
		}
		function dropLoot(loot) {
			let newLoot = new Loot(loot.x, loot.y, loot.radius, loot.name, loot.spellBookName, loot.rarity, loot.dropChance, loot.appearance, loot.form, loot.type, loot.essenceName, loot.pagesToCraft, loot.essenceToCraft, loot.ignoreCollision, loot.amount, loot.stackLimit, loot.text)
			lootsArray.push(newLoot);
		}
		function castSpell(spell) {
			let newSpell = new Spell(
				spell.x,
				spell.y,
				spell.radius,
				spell.FOVRadius,
				spell.name,
				spell.spellBookID,
				spell.caster,
				spell.side,
				spell.target,
				spell.art,
				spell.shape,
				spell.appearance,
				spell.castAmount,
				spell.maxAmount,
				spell.ignoreSpellCollision,
				spell.ignoreMobCollision,
				spell.positionIndex,
				spell.health,
				spell.defense,
				spell.damage,
				spell.speed,
				spell.ability,
				spell.manaCost,
				spell.summonCost,
				spell.respawnTime);
			spellsArray.push(newSpell);
		}
		function spawnMobs() {
			for (let i = 0; i < starterMobsArray.length; i++) {
				for (let j = 0; j < (starterMobsArray[i].maxAmount) * 3; j++) {
					let mobRandomX = ((biome1.x - camera.x) + (Math.floor((Math.random() * (starterMobsArray[i].setMaxX - starterMobsArray[i].setMinX + 1)) + starterMobsArray[i].setMinX))) + camera.x;
					let mobRandomY = ((biome1.y - camera.y) + (Math.floor((Math.random() * (starterMobsArray[i].setMaxY - starterMobsArray[i].setMinY + 1)) + starterMobsArray[i].setMinY))) + camera.y;
					let mobRandomRadiusXHealth = Math.floor((Math.random() * (starterMobsArray[i].setMaxHealth - starterMobsArray[i].setMinHealth + 1)) + starterMobsArray[i].setMinHealth);
					let newMob = new Mob(
						starterMobsArray[i].setMinX, starterMobsArray[i].setMaxX, starterMobsArray[i].setMinY, starterMobsArray[i].setMaxY,
						mobRandomX,
						mobRandomY,
						starterMobsArray[i].appearance,
						starterMobsArray[i].ignoreSpellCollision,
						starterMobsArray[i].ignoreMobCollision,
						mobRandomRadiusXHealth,
						starterMobsArray[i].defense,
						starterMobsArray[i].damage,
						mobRandomRadiusXHealth,
						starterMobsArray[i].radiusAdjust,
						starterMobsArray[i].movementSpeed,
						starterMobsArray[i].turnSpeed,
						starterMobsArray[i].FOVRadius,
						starterMobsArray[i].setMinHealth,
						starterMobsArray[i].setMaxHealth,
						starterMobsArray[i].name,
						starterMobsArray[i].side,
						starterMobsArray[i].maxAmount,
						starterMobsArray[i].type,
						starterMobsArray[i].ability,
						starterMobsArray[i].learnedSpells,
						starterMobsArray[i].castAmount,
						starterMobsArray[i].castDelay,
						starterMobsArray[i].intelligence,
						starterMobsArray[i].experienceDrop,
						starterMobsArray[i].lootDrop, 0, 0,
						starterMobsArray[i].respawnTime);
					mobsArray.push(newMob);
				}
			}
		}
		function crashWith(mob1Array, mob2Array) {
			mob1Array.forEach(mob1 => {
				mob2Array.forEach(mob2 => {
					let dx = mob2.x - mob1.x;
					let dy = mob2.y - mob1.y;
					let distance = Math.sqrt(dx * dx + dy * dy);
					let radii = mob1.radius + mob2.radius;

					if (distance < radii) {

						// Apply knockback
						const angle = Math.atan2(dy, dx);
						const knockbackDistance = (radii - distance) / 2; // Prevent overlap
						if (!mob1.ignoreMobCollision) {
							mob1.x -= Math.cos(angle) * knockbackDistance;
							mob1.y -= Math.sin(angle) * knockbackDistance;
							if (mob1.x < mob1.radius) mob1.x = mob1.radius;
							if (mob1.x > biome1.width - mob1.radius) mob1.x = biome1.width - mob1.radius;
							if (mob1.y < mob1.radius) mob1.y = mob1.radius;
							if (mob1.y > biome1.height - mob1.radius) mob1.y = biome1.height - mob1.radius;
						}
						if (!mob2.ignoreMobCollision) {
							mob2.x += Math.cos(angle) * knockbackDistance;
							mob2.y += Math.sin(angle) * knockbackDistance;
							if (mob2.x < mob2.radius) mob2.x = mob2.radius;
							if (mob2.x > biome1.width - mob2.radius) mob2.x = biome1.width - mob2.radius;
							if (mob2.y < mob2.radius) mob2.y = mob2.radius;
							if (mob2.y > biome1.height - mob2.radius) mob2.y = biome1.height - mob2.radius;
						}
					}
				});
			});
		}
		function playerCollideWithLoot(mob, lootsArray) {
			lootsArray.forEach((loot, index) => {
				let dx = loot.x - mob.x;
				let dy = loot.y - mob.y;
				let distance = Math.sqrt(dx * dx + dy * dy);
				let radii = mob.radius + loot.radius + mob.pickUpRange;

				if (distance < radii) {
					// Collect loot
					// check if the loot should stack
					/* future project
					let allStackableLootArray = inventoryArray.filter(element => element.name === loot.name && element.stackLimit > element.amount);
					console.log(allStackableLootArray);
					if (allStackableLootArray.length > 1) {
						for (let i = 0; i < allStackableLootArray.length; i++) {
							allStackableLootArray[i].amount + allStackableLootArray[i].amount;
						}
					}
					*/
					if (loot.name == "manaOrb") {
						let manaFromOrb = 1;
						if (myGameCharacter.mana + manaFromOrb <= myGameCharacter.maxMana) {
							myGameCharacter.mana += manaFromOrb;
							//console.log("hi");
						}
					} else if (loot.form != "effect") {
						let stackableLootIndex = inventoryArray.findIndex(element => element.name === loot.name && element.stackLimit > element.amount);
						if (stackableLootIndex !== -1 && inventoryArray[stackableLootIndex].amount + loot.amount <= inventoryArray[stackableLootIndex].stackLimit) {
							inventoryArray[stackableLootIndex].amount += loot.amount;
						} else {
							inventoryArray.push(loot);
						}
					}
					lootsArray.splice(index, 1); // Remove loot from the array
				}
			});
		}
		function playerCrashWith(player, mobArray) {
			mobArray.forEach(mob => {
				let dx = mob.x - player.x;
				let dy = mob.y - player.y;
				let distance = Math.sqrt(dx * dx + dy * dy);
				let radii = player.radius + mob.radius;
				if (distance < radii) {
					// Apply knockback
					const angle = Math.atan2(dy, dx);
					const knockbackDistance = (radii - distance) * 4; // Prevent overlap
					if (!player.ignoreMobCollision) {
						player.x -= Math.cos(angle) * knockbackDistance;
						player.y -= Math.sin(angle) * knockbackDistance;
						if (player.x < player.radius) player.x = player.radius;
						if (player.x > biome1.width - player.radius) player.x = biome1.width - player.radius;
						if (player.y < player.radius) player.y = player.radius;
						if (player.y > biome1.height - player.radius) player.y = biome1.height - player.radius;
					}
					if (!mob.ignoreMobCollision) {
						mob.x += Math.cos(angle) * knockbackDistance;
						mob.y += Math.sin(angle) * knockbackDistance;
						if (mob.x < mob.radius) mob.x = mob.radius;
						if (mob.x > biome1.width - mob.radius) mob.x = biome1.width - mob.radius;
						if (mob.y < mob.radius) mob.y = mob.radius;
						if (mob.y > biome1.height - mob.radius) mob.y = biome1.height - mob.radius;
					}

					// Apply damage
					let mobDamage = Math.max(0, mob.damage - player.defense);
					let playerDamage = Math.max(0, player.damage - mob.defense);
					player.health = Math.max(0, player.health - mobDamage);
					mob.health = Math.max(0, mob.health - playerDamage);

					if (player.health <= 0) {
						playerDeath();
					}
				}
			});
		}
		function playerCrashWithSpell(player, spellsArray) {
			spellsArray.forEach(spell => {
				if (spell.art != "books") {
					if (spell.side != player.side) {
						if (spell.shape == "circle") {
							let dx = spell.x - player.x;
							let dy = spell.y - player.y;
							let distance = Math.sqrt(dx * dx + dy * dy);
							let radii = spell.radius + player.radius;
							if (distance < radii) {
								simulateCollision();
							}
						}
						if (spell.shape == "line") {
							// Calculate the closest point on the line segment to the circle center
							const lineStart = { x: spell.x, y: spell.y };
							const lineEnd = { x: spell.x2, y: spell.y2 };
							const circleCenter = { x: player.x, y: player.y };

							// Vector from line start to circle center
							const lineToCircle = {
								x: circleCenter.x - lineStart.x,
								y: circleCenter.y - lineStart.y
							};

							// Line segment vector
							const lineVector = {
								x: lineEnd.x - lineStart.x,
								y: lineEnd.y - lineStart.y
							};

							// Calculate projection of lineToCircle onto lineVector
							const lineLengthSquared = lineVector.x * lineVector.x + lineVector.y * lineVector.y;
							let t = ((lineToCircle.x * lineVector.x) + (lineToCircle.y * lineVector.y)) / lineLengthSquared;

							// Clamp t to stay within the segment bounds
							t = Math.max(0, Math.min(1, t));

							// Find the closest point on the line segment
							const closestPoint = {
								x: lineStart.x + t * lineVector.x,
								y: lineStart.y + t * lineVector.y
							};

							// Distance from circle center to closest point
							const dx = closestPoint.x - circleCenter.x;
							const dy = closestPoint.y - circleCenter.y;
							const distance = Math.sqrt(dx * dx + dy * dy);

							if (distance < player.radius) {
								simulateCollision();
							}
						}
						function simulateCollision() {

							let spellDamage = Math.max(0, spell.damage - player.defense);
							let playerDamage = Math.max(0, player.damage - spell.defense);
							player.health = Math.max(0, player.health - spellDamage);
							spell.health = Math.max(0, spell.health - playerDamage);

							// Check if the player should die and be removed
							if (player.health <= 0) {
								playerDeath();
							}
							// Remove the spell only if its health is <= 0 after damaging all mobs
							if (spell.health <= 0) {
								myGameCharacter.speed = constantPlayerSpeed;
								spell.destroy();
							}

							// Apply knockback to both spell and player
							const dx = player.x - spell.x;
							const dy = player.y - spell.y;
							const angle = Math.atan2(dy, dx);
							const knockbackDistance = 2;

							if (!spell.ignoreMobCollision) {
								spell.x -= Math.cos(angle) * knockbackDistance;
								spell.y -= Math.sin(angle) * knockbackDistance;
							}
							if (!player.ignoreSpellCollision) {
								player.x += Math.cos(angle) * knockbackDistance;
								player.y += Math.sin(angle) * knockbackDistance;
								if (player.x < player.radius) player.x = player.radius;
								if (player.x > biome1.width - player.radius) player.x = biome1.width - player.radius;
								if (player.y < player.radius) player.y = player.radius;
								if (player.y > biome1.height - player.radius) player.y = biome1.height - player.radius;
							}
						}
					}
				}
			});
		}
		function crashWithSpell(spellsArray, mobArray) {
			spellsArray.forEach(spell => {
				if (spell.art != "books") {
					for (let mobIndex = 0; mobIndex < mobArray.length; mobIndex++) {
						let mob = mobArray[mobIndex];
						if (spell.side != mob.side) {
							if (spell.shape == "circle") {
								let dx = spell.x - mob.x;
								let dy = spell.y - mob.y;
								let distance = Math.sqrt(dx * dx + dy * dy);
								let radii = spell.radius + mob.radius;
								if (distance < radii) {
									simulateCollision();
								}
							}
							if (spell.shape == "line") {
								// Calculate the closest point on the line segment to the circle center
								const lineStart = { x: spell.x, y: spell.y };
								const lineEnd = { x: spell.x2, y: spell.y2 };
								const circleCenter = { x: mob.x, y: mob.y };

								// Vector from line start to circle center
								const lineToCircle = {
									x: circleCenter.x - lineStart.x,
									y: circleCenter.y - lineStart.y
								};

								// Line segment vector
								const lineVector = {
									x: lineEnd.x - lineStart.x,
									y: lineEnd.y - lineStart.y
								};

								// Calculate projection of lineToCircle onto lineVector
								const lineLengthSquared = lineVector.x * lineVector.x + lineVector.y * lineVector.y;
								let t = ((lineToCircle.x * lineVector.x) + (lineToCircle.y * lineVector.y)) / lineLengthSquared;

								// Clamp t to stay within the segment bounds
								t = Math.max(0, Math.min(1, t));

								// Find the closest point on the line segment
								const closestPoint = {
									x: lineStart.x + t * lineVector.x,
									y: lineStart.y + t * lineVector.y
								};

								// Distance from circle center to closest point
								const dx = closestPoint.x - circleCenter.x;
								const dy = closestPoint.y - circleCenter.y;
								const distance = Math.sqrt(dx * dx + dy * dy);

								if (distance < mob.radius) {
									simulateCollision();
								}
							}
							function simulateCollision() {

								// Apply damage to the mob
								let calculatedSpellDamage = spell.damage - mob.defense;
								if (calculatedSpellDamage <= 0) {
									calculatedSpellDamage = 0;
								}
								mob.health -= calculatedSpellDamage;

								let calculatedMobDamage = mob.damage - spell.defense;
								if (calculatedMobDamage <= 0) {
									calculatedMobDamage = 0;
								}
								// Apply damage to the spell
								spell.health -= calculatedMobDamage;

								// Check if the mob should die and be removed
								if (mob.health <= 0) {
									myGameCharacter.experience += mob.experienceDrop;
									levelUp();
									mob.spawn();
									mob.die();
									mobArray.splice(mobIndex, 1);
									mobIndex--; // Adjust index after removal
								}
								// Remove the spell only if its health is <= 0 after damaging all mobs
								if (spell.health <= 0) {
									//temporary solution to bug number 3. make sure to finalize this
									myGameCharacter.speed = constantPlayerSpeed;
									spell.destroy();
								}
								// Apply knockback to both spell and mob
								const dx = mob.x - spell.x;
								const dy = mob.y - spell.y;
								const angle = Math.atan2(dy, dx);
								const knockbackDistance = 2;

								if (!spell.ignoreMobCollision) {
									spell.x -= Math.cos(angle) * knockbackDistance;
									spell.y -= Math.sin(angle) * knockbackDistance;
								}
								if (!mob.ignoreSpellCollision) {
									mob.x += Math.cos(angle) * knockbackDistance;
									mob.y += Math.sin(angle) * knockbackDistance;
									if (mob.x < mob.radius) mob.x = mob.radius;
									if (mob.x > biome1.width - mob.radius) mob.x = biome1.width - mob.radius;
									if (mob.y < mob.radius) mob.y = mob.radius;
									if (mob.y > biome1.height - mob.radius) mob.y = biome1.height - mob.radius;
								}
							}
						}
					}
				}
			});
		}
		function getDistance(circle1, circle2) {
			let a = circle2.y - circle1.y;
			let b = circle2.x - circle1.x;
			return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
		}
		/*
		tasks:
		7). add a notification type of feature when a skill is used to show when player has insufficient mana
		8). add upgrades points. you can earn ugrade points when leveling up
		12). add a way to access spell books in game
		13). add a notification type of feature when a skill is used to show when player has insufficient mana
		14). add spells that can be casted multiple times in a row but they rely heavily on mana (they're a different type from spellBooks)
		15). make the spellBooks run on cooldown instead of mana
		1000). add a place where npcs will go to when their kingdom is invaded
		1001). most people arent allowed to go to that place because that place is only for emergencies and they cant risk it getting invaded
		1002). make npcs killable (someone rich and willing needs to resurect them) (there will be a sign that says theyve been killed or something)
		1003). squads/teams will be a thing where friends can play together
		1004). there should be a local gamemode so people can still have fun
		1005). only add some ads
		1006). ranks should be a thing
		1007). a spellBook that progressively gets stronger the more mobs you kill

		game issues to fix:
		bug 2 is fixed. but im not removing it because it has existed for years and only got removed today 17/10/2024 3:37 AM
		2). the spell book issue happens when a spell book hits 2 basic mob at the same time because the crashWith function is called twice and deletes 2 spellbooks.
		3). on the spell aoe ability, the player speed reverting back to normal value doesn't work when the spell
		finishes its job because it gets destroyed by a mob before it can even apply the code line.
		this also applies to the beams, we just didn't notice.
		4). spell line to circle knockback doesn't work properly. it pulls the circle instead of pushing away.
		*/
	</script>
</body>
</html>
