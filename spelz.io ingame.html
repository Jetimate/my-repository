<!DOCTYPE html>
<html>
<head>

<style>
canvas {
    border:1px solid #d3d3d3;
    background-color: #f1f1f1;
}
button {
    height: 100px;
	width: 100px;
}
</style>
</head>
<body onload="startGame()">
	<canvas id="mycanvas"></canvas>
	<script type="text/javascript" src="js/mob.js"></script>
	<script type="text/javascript" src="js/playable-character.js"></script>
	<script type="text/javascript" src="js/spellbook.js"></script>
	<script>
        let mobArray = [];
        let spellBooks;
        let maxSpellBooks = 3;
		var pi = 3.14159;
		
		var myGameArea = {
			activeKeys: [],
			validKeys: [37, 38, 39, 40, 65, 68, 83, 87, 97, 100, 119, 115, 32, 16],
			canvas: document.getElementById("mycanvas"),
			start: function () {               
				this.context = this.canvas.getContext("2d");                
				this.interval = setInterval(updateGameArea, 20);
				window.addEventListener('keydown', function (e) {
					var isKeyActive = myGameArea.activeKeys.indexOf(e.keyCode) >= 0;
					if (!isKeyActive) {
						var isValidKey = myGameArea.validKeys.indexOf(e.keyCode) >= 0;
						if (isValidKey) {
							myGameArea.activeKeys.push(e.keyCode);
						}
					}
					console.log(myGameArea.activeKeys);
					console.log("keydown");
				});
				window.addEventListener('keyup', function (e) {
					var keyIndex = myGameArea.activeKeys.indexOf(e.keyCode);
					var isKeyActive = keyIndex >= 0;
					if (isKeyActive) {
						myGameArea.activeKeys.splice(keyIndex, 1);
					}
					console.log(myGameArea.activeKeys);
					console.log("keyup");
				});
				this.canvas.addEventListener("mousedown", function (e) {
					if (e.button === 0) {
                        getMousePosition(myGameArea.canvas, e);
						console.log("Left mouse is clicked");
					} else if (e.button === 2) {
						console.log("Right mouse is clicked");
					}
				});
			},
			clear: function () {
				this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
			},
			stop: function () {
				clearInterval(this.interval);
			}
		}		
        function startGame() {
            myGameCharacter = new PlayableCharacter(300, 300, 15, "yellow", 150, 10);
            mobArray.push(new Mob(200, 200, 30, "red", 30, 1));
            mobArray.push(new Mob(440, 582, 30, "red", 30, 1));
            myGameArea.start();
            myGameCharacter.update();
            mobArray.forEach(item => {
                item.update();
            });
            spellBooksKeeper();
        }
		function spellBooksKeeper() {
			spellBooks = [];
			spellBooks.push(new SpellBook(myGameCharacter.x, myGameCharacter.y, 10, 'gray', 45, 20, 70, 1, 1, 1500));
			spellBooks.push(new SpellBook(myGameCharacter.x, myGameCharacter.y, 10, 'gray', 45, 20, 70, 1, 1, 1500));
			spellBooks.push(new SpellBook(myGameCharacter.x, myGameCharacter.y, 10, 'gray', 45, 20, 70, 1, 1, 1500));
			for (var i = 0; i < spellBooks.length; i++) {
				if (i > 0)
					spellBooks[i].radian = ((i * pi) / maxSpellBooks) * 2;

				console.log(spellBooks[i].radian);
			}
		}
		function spellBooksUpdater() {
			spellBooks.forEach(spellBook => {
				spellBook.startingPos = {
					x: myGameCharacter.x,
					y: myGameCharacter.y
				}
				if (spellBook.orbitRadius < spellBook.normalOrbitRadius) {
					spellBook.orbitRadius += 1;
				}
				else if (spellBook.orbitRadius > spellBook.normalOrbitRadius) {
					spellBook.orbitRadius -= 1;
				}
				spellBook.update();
			});
		}
		function updateGameArea() {
			if (crashWith(myGameCharacter, mobArray)) {
				myGameArea.activeKeys = [];
				mobArray = [];
				spellBooks = [];
				alert("game over");
				myGameArea.stop();
				myGameArea.clear();

				startGame();
			}
			else if (crashWithSpellBook(spellBooks, mobArray)) {
				myGameArea.clear();
				myGameCharacter.x += myGameCharacter.speedX;
				myGameCharacter.y += myGameCharacter.speedY;
				spellBooksUpdater();
				myGameCharacter.update();
				mobArray.forEach(mob => {
					mob.update();
				});
			}
			else if (myGameArea.activeKeys.length == 0) {
                myGameArea.context.canvas.width = window.innerWidth - 25;
                myGameArea.context.canvas.height = window.innerHeight - 25;
			   	myGameArea.clear();
				spellBooksUpdater();
				myGameCharacter.update();
                spellBooks.forEach(spellBook => {
                    spellBook.color = 'gray';
                });
				mobArray.forEach(mob => {
					mob.update();
				});				
				return;
			}
			else {
				myGameArea.clear();
				myGameCharacter.x += myGameCharacter.speedX;
				myGameCharacter.y += myGameCharacter.speedY;
				spellBooksUpdater();
				myGameCharacter.update();               
				mobArray.forEach(mob => {
					mob.update();
				});
			}

			myGameCharacter.speedX = 0;
			myGameCharacter.speedY = 0;
			var gameSpeed = myGameCharacter.speed;

			for (var i = 0; i < myGameArea.activeKeys.length; i++) {
				var key = myGameArea.activeKeys[i];

				if ((key == 37 || key == 65 || key == 97) && (myGameCharacter.speedX > -gameSpeed)) {
					myGameCharacter.speedX -= gameSpeed;
				}
				if ((key == 39 || key == 68 || key == 100) && (myGameCharacter.speedX < gameSpeed)) {
					myGameCharacter.speedX += gameSpeed;
				}
				if ((key == 38 || key == 87 || key == 119) && (myGameCharacter.speedY > -gameSpeed)) {
					myGameCharacter.speedY -= gameSpeed;
				}
				if ((key == 40 || key == 83 || key == 115) && (myGameCharacter.speedY < gameSpeed)) {
					myGameCharacter.speedY += gameSpeed;
				}
				if (key == 32) {
					spellBooks.forEach(spellBook => {
						if (spellBook.orbitRadius < spellBook.attackOrbitRadius) {
							spellBook.orbitRadius += 2;
							spellBook.color = 'red';
						}
					});
				}
				if (key == 16) {
					console.log("17");
					spellBooks.forEach(spellBook => {
						if (spellBook.orbitRadius > spellBook.defendOrbitRadius) {
							spellBook.orbitRadius -= 2;
							spellBook.color = 'green';
						}
					});
				}
			}
		}
        function getMousePosition(canvas, event) {
	        let rect = canvas.getBoundingClientRect();
	        let x = event.clientX - rect.left;
			let y = event.clientY - rect.top;			
			spellBooks[0].x = x;
			spellBooks[0].y = y;
			spellBooks[0].defendOrbitRadius = 0;
            spellBooks[0].normalOrbitRadius = 0;
			spellBooks[0].attackOrbitRadius = 0;
			spellBooks[0].velocity = 0;   
//		    console.log("Coordinate x: " + x);
//		    console.log("Coordinate y: " + y);
//		    console.log(" ");
		} 
		function projectileUpdate() {
		//something	
		}
      
		function crashWith(spellBook, mobs) {
			let result = false;
			mobs.forEach(mob => {
				let radii = spellBook.radius + mob.radius;
				let distance = getDistance(spellBook, mob);
				let hasCrashed = distance < radii;
				if (hasCrashed) {
					result = hasCrashed;
				}
			});
			return result;
		}
		function crashWithSpellBook(spellBooks, mobs) {
			let result = false;
			spellBooks.forEach(spellBook => {
				var mobIndex = 0;
				mobs.forEach(mob => {
					let radii = spellBook.radius + mob.radius;
					let distance = getDistance(spellBook, mob);
					let hasCrashed = distance < radii;
					if (hasCrashed) {
						result = hasCrashed;
						mob.health -= spellBook.damage;
						mob.radius -= spellBook.damage;
						spellBook.health -= mob.damage
						console.log("mob health: " + mob.health);
						if (mob.health <= 0) {
							mobs.splice(mobIndex, 1);
						}
						else if (spellBook.health <= 0) {
							var spellBookIndex = spellBooks.indexOf(spellBook);
							spellBooks.splice(spellBookIndex, 1);					
							setTimeout(function () {
								let spellBook1Radian = 0;
								if (spellBooks.length > 0) {
									spellBook1Radian = spellBooks[0].radian;
								}
								let newSpellBook = new SpellBook(myGameCharacter.x, myGameCharacter.y, 10, 'gray', 45, 20, 70, 1, 1, 1500);					
								let radianMultiplier = (pi / maxSpellBooks) * 2;
								if (spellBooks.length > 0) {
									newSpellBook.radian = spellBook1Radian + (radianMultiplier * spellBooks.length);
								}
								else {
									newSpellBook.radian = 0;
								}
								spellBooks.push(newSpellBook);
							},
								spellBook.respawnTime
							);
						}
						mob.update();
					}
					mobIndex++;
				});
			});
			return result;
		}
		function getDistance(circle1, circle2) {
			let a = circle2.y - circle1.y;
			let b = circle2.x - circle1.x;
			return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
		}
/*	task of the week:
1). add fire guided projectile
2). fix player death update
3). fix deprecated keycode
4). make it easier to add petals / make a shortcut for adding petals
*/
	</script>
</body>
</html>
