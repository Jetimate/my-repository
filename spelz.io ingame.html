<!DOCTYPE html>
<html>
<head>
	<title>Spelz.io</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
		html, body {
			height: 100%;
			margin: 0;
		}

		button {
			height: 100px;
			width: 100px;
		}

        div {
            /*border: 1px solid blue;*/
        }

        #mycanvas {
            border: 1px solid #d3d3d3;
            background-color: #f1f1f1;
            position: absolute;
            z-index: -1;
        }

		#mainMenu {
			border: 1px solid blue;
			position: absolute;
			z-index: 1;
			height: calc(100% - 7px);
			width: calc(100% - 7px);
			display: flex;
			flex-direction: row;
			justify-content: space-between;
			align-content: flex-start;
			padding: 2px;
		}
        #inputUserName {
           width:500px;
		   height:50px;
        }

		.spelzio {
			margin: 0;
			font-size: 180px;
		}

		.notstart {
			width: 100px;
			height: 70px;
			margin: 3px;
		}

		.containera {
			display: flex;
			flex-direction: column;
			justify-content: space-between;
		}

		.item1a {
			text-align: center;
			margin: 2px;
		}

		.item2a {
			text-align: start;
			margin: 2px;
			padding: 0px;
			font-size: 25px;
		}

		.containerb {
			display: flex;
			flex-direction: column;
			justify-content: center;
			flex-grow: 1;
			margin: 2px;
		}

		.item1b {
			margin: 10px;
			text-align: center;
			margin: 2px;
			font-size: 40px;
		}

		.containerc {
			text-align: end;
			margin: 2px;
			padding: 2px 10px 2px 10px;
		}
	</style>
</head>
<body>
	<canvas id="mycanvas"></canvas>
	<div id="mainMenu">
		<div class="containera">
			<div class="item1a">
				<button class="notstart">settings</button>
				<button class="notstart">changelog</button>
			</div>
			<div class="item2a">
				<button class="notstart">friends</button><br>
				<button class="notstart">spelz</button><br>
				<button class="notstart">monster gallery</button>
			</div>
		</div>
		<div class="containerb">
			<div class="item1b">
				<h1 class="spelzio">spelz.io</h1>
				<input id="inputUserName" type="text" placeholder="Name" />
				<button id="startGameButton" onclick="startGame()">start game</button>
			</div>
		</div>
		<div class="containerc">
			<a href="signin.html">sign in</a>
		</div>
	</div>
	<script type="text/javascript" src="js/mob.js"></script>
	<script type="text/javascript" src="js/playable-character.js"></script>
	<script type="text/javascript" src="js/spellbook.js"></script>
	<script type="text/javascript" src="js/button.js"></script>

	<script>
        const keys = {
            KeyW: false,
            KeyA: false,
            KeyS: false,
			KeyD: false,
			ArrowUp: false,
			ArrowDown: false,
			ArrowLeft: false,
			ArrowRight: false,
			ShiftLeft: false,
			ShiftRight: false,
			Space: false,
            KeyV: false,
            KeyB: false
		};
        let xVelocity = 1;
        let yVelocity = 1;
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
		let levelBarButton;
		let experienceBarButton;
		let healthBarButton;
        let manaBarButton;
		let basicMobArray = [];
		let stage2MobArray = [];
		let spellBooks = [];
		let spawnSpellBookTimeout = [];
		let maxAmountBasicMob = 5;
		let maxAmountStage2Mob = 3;
		let maxSpellBooks = 2;
		let maxExperience = 20;
		const canvas = document.getElementById("mycanvas");
        const ctx = canvas.getContext("2d");
		const pi = 3.14159;
		const basicSpellBook = {
			radius: 15,
			type: "image",
			color: "luminousSpirit.png",
            index: 1,
			normalOrbitRadius: 45,
			defendOrbitRadius: 20,
			attackOrbitRadius: 140,
			health: 10,
            damage: 5,
            respawnTime: 1500
        };

		var myGameArea = {
			canvas: document.getElementById("mycanvas"),
			start: function () {
				this.context = this.canvas.getContext("2d");
                this.interval = setInterval(updateGameArea, 20);
				window.addEventListener('click', function (e) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
					const y = e.clientY - rect.top;
					levelBarButton.clickButton(x, y);
                    experienceBarButton.clickButton(x, y);
					healthBarButton.clickButton(x, y);
                    manaBarButton.clickButton(x, y);
				});
				window.addEventListener('mousedown', (event) => {
//                    console.log(event);
                    isMouseDown = true;
                    const rect = canvas.getBoundingClientRect();
                    mouseX = event.clientX - rect.left;
                    mouseY = event.clientY - rect.top;
                });

                window.addEventListener('mouseup', () => {
                    isMouseDown = false;
                });

                window.addEventListener('mousemove', (event) => {
                    if (isMouseDown) {
                        const rect = canvas.getBoundingClientRect();
                        mouseX = event.clientX - rect.left;
                        mouseY = event.clientY - rect.top;
                    }
				});
                // Key down event listener
				window.addEventListener('keydown', (event) => {
				//	console.log(event);
                    if (event.code in keys) {
                        keys[event.code] = true;
                    }
                });

                // Key up event listener
                window.addEventListener('keyup', (event) => {
                    if (event.code in keys) {
                        keys[event.code] = false;
                    }
                });
			},
			clear: function () {
				this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
			},
			stop: function () {
				clearInterval(this.interval);
			}
		}
		function startGame() {
			for (var i = 0; i < spawnSpellBookTimeout.length; i++) {
				clearTimeout(spawnSpellBookTimeout[i]);
			}
			spawnSpellBookTimeout = [];
            myGameArea.activeKeys = [];
			basicMobArray = [];
			stage2MobArray = [];
			spellBooks = [];
			maxExperience = 20;
            myGameCharacter = new PlayableCharacter(300, 300, 20, "smileyy.webp", 90, 150, 0, "image", 0, 0, 0.01, 0.5);
			if (levelBarButton == undefined) {
                levelBarButton = new Button(5, 5, 200, 50, [5], "#5fa7e5", "level: " + myGameCharacter.level);
			}
			if (experienceBarButton == undefined) {
                experienceBarButton = new Button(5, 60, 200, 50, [5], "#ffd15d", "experience: " + myGameCharacter.experience);
			}
            if (healthBarButton == undefined) {
                healthBarButton = new Button(5, 115, 200, 50, [5], "#ff5d70", "health: " + myGameCharacter.health);
			}
            if (manaBarButton == undefined) {
                manaBarButton = new Button(5, 170, 200, 50, [5], "#dbcff8", "mana: " + myGameCharacter.mana);
            }
			spawnBasicMob();
			spawnStage2Mob();
			myGameArea.start();
			spellBooksKeeper();
			var mainMenuVariable = document.getElementById("mainMenu");
			if (mainMenuVariable) {
				mainMenuVariable.remove();
			}
            //levelBarButton.text = "level: " + myGameCharacter.level;
            //experienceBarButton.text = "experience: " + myGameCharacter.experience;
            //healthBarButton.text = "health: " + myGameCharacter.health;
            //statPointsButton.text = "stat points: " + myGameCharacter.level;
		}
		function spellBooksKeeper() {
            spawnSpellBook(new SpellBook(myGameCharacter.x, myGameCharacter.y, basicSpellBook.radius, basicSpellBook.type, basicSpellBook.color, 0, basicSpellBook.normalOrbitRadius, basicSpellBook.defendOrbitRadius, basicSpellBook.attackOrbitRadius, basicSpellBook.health, basicSpellBook.damage, basicSpellBook.respawnTime), 10);
            spawnSpellBook(new SpellBook(myGameCharacter.x, myGameCharacter.y, basicSpellBook.radius, basicSpellBook.type, basicSpellBook.color, 1, basicSpellBook.normalOrbitRadius, basicSpellBook.defendOrbitRadius, basicSpellBook.attackOrbitRadius, basicSpellBook.health, basicSpellBook.damage, basicSpellBook.respawnTime), 10);
            }
		function spellBooksUpdater() {
			spellBooks.forEach(spellBook => {
				spellBook.startingPos = {
					x: myGameCharacter.x,
					y: myGameCharacter.y
				}
				if (spellBook.orbitRadius < spellBook.normalOrbitRadius) {
					spellBook.orbitRadius += 1;
				}
				else if (spellBook.orbitRadius > spellBook.normalOrbitRadius) {
					spellBook.orbitRadius -= 1;
				}
				spellBook.update();
			});
		}
		function updateGameArea() {
			// always updating
			myGameArea.clear();
			myGameArea.context.canvas.width = window.innerWidth - 3;
			myGameArea.context.canvas.height = window.innerHeight - 3;
			spellBooksUpdater();
			myGameCharacter.playerNewPos();
			myGameCharacter.update();
			myGameCharacter.regenerateHealth();
			myGameCharacter.regenerateMana();
			updatePlayerPosition();
			basicMobArray.forEach(basicMob => {
				basicMob.update();
			});	
            stage2MobArray.forEach(stage2Mob => {
				stage2Mob.update();
				stage2Mob.newPos();
                stage2Mob.move();
            });
			levelBarButton.draw(ctx);
			experienceBarButton.draw(ctx);
			healthBarButton.draw(ctx);
            manaBarButton.draw(ctx);
			// player and mob collision
		    if (playerCrashWith(myGameCharacter, basicMobArray) || playerCrashWith(myGameCharacter, stage2MobArray)) {
                myGameCharacter.playerNewPos();
            }
			// mob to mob collision
            if (crashWith(stage2MobArray, basicMobArray) ||
				crashWith(stage2MobArray, stage2MobArray)) {
                myGameCharacter.playerNewPos();
			}
			if (crashWith(basicMobArray, basicMobArray)) {
                myGameCharacter.playerNewPos();
			}
			// hitting a basic mob
            if (crashWithSpellBook(spellBooks, basicMobArray) || crashWithSpellBook(spellBooks, stage2MobArray)) {
                myGameCharacter.playerNewPos();
			}
			//updates when moving
			else {
				myGameCharacter.playerNewPos();
			}
            myGameCharacter.movementX = 0;
			myGameCharacter.movementY = 0;
			myGameCharacter.moveAngle = 0;
			myGameCharacter.speed = 0;
            // attack/spacebar
			if (keys.Space) {
                spellBooks.forEach(spellBook => {
                    if (spellBook.orbitRadius < spellBook.attackOrbitRadius) {
						spellBook.orbitRadius += 2;
                    }
				});
                myGameCharacter.playerNewPos();
            }
            // defend/shift
			if (keys.ShiftLeft || keys.ShiftRight) {
                spellBooks.forEach(spellBook => {
                    if (spellBook.orbitRadius > spellBook.defendOrbitRadius) {
                        spellBook.orbitRadius -= 2;
                    }
				});
                myGameCharacter.playerNewPos();
			}
			// spawn more spellbooks
            if (keys.KeyV) {
				if (myGameCharacter.mana > 10) {
					myGameCharacter.mana -= 10;
					basicSpellBook.index += 1;
					spawnSpellBook(new SpellBook(myGameCharacter.x, myGameCharacter.y, basicSpellBook.radius, basicSpellBook.type, basicSpellBook.color, basicSpellBook.index, basicSpellBook.normalOrbitRadius, basicSpellBook.defendOrbitRadius, basicSpellBook.attackOrbitRadius, basicSpellBook.health, basicSpellBook.damage, basicSpellBook.respawnTime), 10);
					myGameCharacter.playerNewPos();
				}
			}
			//deletes spellbooks
			if (keys.KeyB) {
				if (basicSpellBook.index >= maxSpellBooks) {
					spellBooks.splice(basicSpellBook.index, 1);
					basicSpellBook.index -= 1;
					myGameCharacter.playerNewPos();
				}
            }
			function updatePlayerPosition() {
				if ((keys.KeyW || keys.ArrowUp) && (keys.KeyA || keys.ArrowLeft)) { // Up-Left
					myGameCharacter.angle = (1.75 * Math.PI);
					myGameCharacter.speed = 1;
				} else if ((keys.KeyW || keys.ArrowUp) && (keys.KeyD || keys.ArrowRight)) { // Up-Right
					myGameCharacter.angle = (2.25 * Math.PI);
					myGameCharacter.speed = 1;
				} else if ((keys.KeyS || keys.ArrowDown) && (keys.KeyA || keys.ArrowLeft)) { // Down-Left
					myGameCharacter.angle = (1.25 * Math.PI);
					myGameCharacter.speed = 1;
				} else if ((keys.KeyS || keys.ArrowDown) && (keys.KeyD || keys.ArrowRight)) { // Down-Right
					myGameCharacter.angle = (0.75 * Math.PI);
					myGameCharacter.speed = 1;
				} else if (keys.KeyW || keys.ArrowUp) { // Up
					myGameCharacter.angle = (2 * Math.PI);
					myGameCharacter.speed = 1;
				} else if (keys.KeyS || keys.ArrowDown) { // Down
					myGameCharacter.angle = (1 * Math.PI);
					myGameCharacter.speed = 1;
				} else if (keys.KeyA || keys.ArrowLeft) { // Left
					myGameCharacter.angle = (1.5 * Math.PI);
					myGameCharacter.speed = 1;
				} else if (keys.KeyD || keys.ArrowRight) { // Right
					myGameCharacter.angle = (0.5 * Math.PI);
					myGameCharacter.speed = 1;
				}
			}
		}
		function playerDeath() {
            alert("game over");
            myGameArea.stop();
            startGame();
		}
        function levelUp() {
            if (myGameCharacter.experience >= maxExperience) {
                myGameCharacter.experience -= maxExperience;
                maxExperience += 20;
                myGameCharacter.level += 1;
            }
            experienceBarButton.text = "experience: " + myGameCharacter.experience;
            levelBarButton.text = "level: " + myGameCharacter.level;
        }
		function spawnBasicMob() {
			let me = this;
			setTimeout(function () {
				if (basicMobArray.length < maxAmountBasicMob) {
					// for x 1250 - 100 + 1)) + 100
					// for y 750 - 100 + 1)) + 100
                    let basicMobRandomX = Math.floor((Math.random() * (1250 - 100 + 1)) + 100);
                    let basicMobRandomY = Math.floor((Math.random() * (750 - 100 + 1)) + 100);
					let basicMobRandomRadiusXHealth = Math.floor((Math.random() * (70 - 15 + 1)) + 15);
					let basicMobRandomExperienceDrop = Math.floor((Math.random() * (15 - 5 + 1)) + 5);
                    let newBasicMob = new BasicMob(basicMobRandomX, basicMobRandomY, basicMobRandomRadiusXHealth, "luminousRock.png", basicMobRandomRadiusXHealth, 1, "image", 0, basicMobRandomExperienceDrop);
					basicMobArray.push(newBasicMob);
					if (basicMobArray.length < maxAmountBasicMob) {
						me.spawnBasicMob();
					}
				}
			}, 3000);
		}
		function spawnStage2Mob() {		
            let me = this;
            setTimeout(function () {
                if (stage2MobArray.length < maxAmountStage2Mob) {
                    let stage2MobRandomX = Math.floor((Math.random() * (1250 - 100 + 1)) + 100);
                    let stage2MobRandomY = Math.floor((Math.random() * (750 - 100 + 1)) + 100);
                    let stage2MobRandomRadiusXHealth = Math.floor((Math.random() * (70 - 15 + 1)) + 15);
                    let stage2MobRandomExperienceDrop = Math.floor((Math.random() * (20 - 5 + 1)) + 5);
                    let newStage2Mob = new Stage2Mob(stage2MobRandomX, stage2MobRandomY, stage2MobRandomRadiusXHealth, "luminousSpirit.png", stage2MobRandomRadiusXHealth, 5, "image", 1, stage2MobRandomExperienceDrop, 0, 0);
					stage2MobArray.push(newStage2Mob);         
                    console.log("mob health: " + newStage2Mob.health + " mob radius: " + newStage2Mob.radius);
                    if (stage2MobArray.length < maxAmountStage2Mob) {
                        me.spawnStage2Mob();
                    }
                }
            }, 4000);
		}
		function spawnSpellBook(spellBook, delay) {
			spawnSpellBookTimeout.push(setTimeout(function () {
				let spellBook1Radian = 0;
                let newSpellBook = new SpellBook(myGameCharacter.x, myGameCharacter.y, basicSpellBook.radius, basicSpellBook.type, basicSpellBook.color, spellBook.positionIndex, basicSpellBook.normalOrbitRadius, basicSpellBook.defendOrbitRadius, basicSpellBook.attackOrbitRadius, basicSpellBook.health, basicSpellBook.damage, basicSpellBook.respawnTime);
				let radianMultiplier = (pi / maxSpellBooks) * 2;
				if (spellBooks.length > 0) {
					spellBook1Radian = spellBooks[0].radian;
					newSpellBook.radian = (spellBook1Radian - (spellBooks[0].positionIndex * radianMultiplier)) + (radianMultiplier * spellBook.positionIndex);
				}
				else {
					newSpellBook.radian = 0;
				}
				spellBooks.push(newSpellBook);
				//console.log(spellBook.radian);
			}, delay)
			);
		}
        function crashWith(mob1Array, mob2Array) {
			let result = false;
			mob1Array.forEach(mob1 => {
				mob2Array.forEach(mob2 => {
					let radii = mob1.radius + mob2.radius;
					let distance = getDistance(mob1, mob2);
					let hasCrashed = distance < radii;
					if (hasCrashed) {
						result = hasCrashed;
						const dx = mob2.x - mob1.x;
						const dy = mob2.y - mob1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minDistance = mob1.radius + mob2.radius;
                        if (distance < minDistance) {
							// Calculate knockback direction
							const angle = Math.atan2(dy, dx);
							const knockbackDistance = 1;
							// Apply knockback
							for (let i = 0; i < 5; i++) {
								mob1.x -= Math.cos(angle) * knockbackDistance;
								mob1.y -= Math.sin(angle) * knockbackDistance;
								mob2.x += Math.cos(angle) * knockbackDistance;
								mob2.y += Math.sin(angle) * knockbackDistance;
							}
						}
					}
				});
			});
			return result;
		}
        function playerCrashWith(mob1, mob2Array) {
        let result = false;
            mob2Array.forEach(mob2 => {
                let radii = mob1.radius + mob2.radius;
                let distance = getDistance(mob1, mob2);
                let hasCrashed = distance < radii;
                if (hasCrashed) {
                   result = hasCrashed;
                   const dx = mob2.x - mob1.x;
				   const dy = mob2.y - mob1.y;
                   // Calculate knockback direction
                   const angle = Math.atan2(dy, dx);
                   const knockbackDistance = 1;
                   // Apply knockback
                   for (let i = 0; i < 7; i++) {
                       mob1.x -= Math.cos(angle) * knockbackDistance;
                       mob1.y -= Math.sin(angle) * knockbackDistance;
                       mob2.x += Math.cos(angle) * knockbackDistance;
                       mob2.y += Math.sin(angle) * knockbackDistance;
                   }
                   mob1.health -= mob2.damage;
                   mob2.health -= mob1.damage;
				   mob2.radius = mob2.health;
                   // player to mob collision
                   healthBarButton.text = "health: " + myGameCharacter.health;
                   if (myGameCharacter.health <= 0) {
					   //death
					   playerDeath();
                   }
                }
            });            
            return result;
        }
		function crashWithSpellBook(spellBooks, mob2Array) {
			let result = false;
			spellBooks.forEach(spellBook => {
                for (let mob2Index = 0; mob2Index < mob2Array.length; mob2Index++) {
                    let mob2 = mob2Array[mob2Index];
                    let radii = spellBook.radius + mob2.radius;
                    let distance = getDistance(spellBook, mob2);
					let hasCrashed = distance < radii;
					if (hasCrashed) {
						result = hasCrashed;
                        if (mob2.health > spellBook.damage && mob2.health > 10) {
                            mob2.health -= spellBook.damage;
                            mob2.radius = mob2.health;
                            spellBook.health -= mob2.damage;
                        } else if (mob2.health <= spellBook.damage || mob2.health <= 10) { 
                            spellBook.health -= mob2.damage;
// bugged part
                            myGameCharacter.experience += mob2.experienceDrop;							
							levelUp();
                            mob2Array.splice(mob2Index, 1);
							mob2.spawn();
						}
						if (spellBook.health <= 0) {
							let spellBookIndex = spellBooks.indexOf(spellBook);
							spellBooks.splice(spellBookIndex, 1);
							if (spellBooks.length < maxSpellBooks) {
								spawnSpellBook(spellBook, spellBook.respawnTime);
							}
						}
                        mob2.update();
                        const dx = mob2.x - spellBook.x;
                        const dy = mob2.y - spellBook.y;
                        // Calculate knockback direction
                        const angle = Math.atan2(dy, dx);
                        const knockbackDistance = 2;
                        // Apply knockback
                        spellBook.x -= Math.cos(angle) * knockbackDistance;
                        spellBook.y -= Math.sin(angle) * knockbackDistance;
                        mob2.x += Math.cos(angle) * knockbackDistance;
                        mob2.y += Math.sin(angle) * knockbackDistance;
					}
				}
			});
			return result;
		}
		function getDistance(circle1, circle2) {
			let a = circle2.y - circle1.y;
			let b = circle2.x - circle1.x;
			return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
		}
/*	
tasks:
6). add player stats(you can change your stats according to the max stats that youve earned; you can lower it to the lowest and increase it to the max stat that you have unlocked)
7). add upgrades points. you can earn ugrade points when killing mobs or when leveling up
8). add a new spellBook other than the basic one
10). make basic mob drop a new spell book
11). make a field of view that follows the player
12). add a way to access spell books in game
13).
101). hard level: fix the spellbook issue
1000). add a place where npcs will go to when their kingdom is invaded
1001). most people arent allowed to go to that place because that place is only for emergencies and they cant risk it getting invaded
1002). make npcs killable (someone rich and willing needs to resurect them) (there will be a sign that says theyve been killed or something)
1003). squads/teams will be a thing where friends can play together
1004). there should be a local gamemode so people can still have fun
1005). only add some ads
1006). ranks should be a thing
1007). a spellBook that progressively gets stronger the more mobs you kill

game issues to fix:
1). buttons multiply when the player dies(restarting the game by command ingame) we need to remove buttons before restarting the game after the player dies.
2). the spell book issue happens when a spell book hits 2 basic mob at the same time because the crashWith function is called twice and deletes 2 spellbooks.
3). mobs don't spawn properly whenever the game over feature is activated
4). stage 2 mobs get draw updated when dying.
*/
	</script>
</body>
</html>
